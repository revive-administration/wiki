a:173:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"1장 IoC 컨테이너와 DI";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:43;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:71:"1.1 IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트";i:1;i:2;i:2;i:43;}i:2;i:43;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:43;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:184:"스프링 애플리케이션에서는 오브젝트의 생성과 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립된 컨테이너가 담당한다. ";}i:2;i:127;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:312;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:312;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:64:"1.1.1 IoC 컨테이너를 이용해 애플리케이션 만들기";i:1;i:3;i:2;i:312;}i:2;i:312;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:312;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:312;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:160:"이렇게 만들어진 컨테이너가 본격적인 IoC 컨테이너로서 동작하려면 두 가지가 필요하다. POJO 클래스와 설정 메타정보다.";}i:2;i:387;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:548;}i:15;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:548;}i:16;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"POJO 클래스";i:1;i:4;i:2;i:548;}i:2;i:548;}i:17;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:548;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:548;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:99:"먼저 애플리케이션의 핵심 코드를 담고 있는 POJO 클래스를 준비해야 한다. ";}i:2;i:571;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:671;}i:21;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:671;}i:22;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"설정 메타정보";i:1;i:4;i:2;i:671;}i:2;i:671;}i:23;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:671;}i:24;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:671;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:238:"두 번째 필요한 것은 앞에서 만든 POJO 클래스들 중에 애플리케이션에서 사용할 것을 선정하고 이를 IoC 컨테이너가 제어할 수 있도록 적절한 메타정보를 만들어 제공하는 작업이다.";}i:2;i:699;}i:26;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:937;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:937;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:351:"IoC 컨테이너의 가장 기초적인 역할은 오브젝트를 생성하고 이를 관리하는 것이다. 스프링 컨테이너가 관리하는 이런 오브젝트는 빈이라고 부른다. IoC 컨테이너가 필요로 하는 설정 메타정보는 바로 이 빈을 어떻게 만들고 어떻게 동작하게 할 것인가에 관한 정보다.";}i:2;i:939;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1290;}i:30;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1290;}i:31;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:408:"스프링의 설정 메타정보는 BeanDefinition 인터페이스로 표현되는 순수한 추상 정보다. 스프링 IoC컨테이너, 즉 애플리케이션 컨텍스트는 바로 이 메타정보의 내용을 표현한것이 있다면 무엇이든 사용 가능하다. BeanDefinitionReader가 있으면 된다. BeanDefinition 인터페이스로 정의되는, 빈 메타정보는 대략 다음과 같다.";}i:2;i:1292;}i:32;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1701;}i:33;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1701;}i:34;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1701;}i:35;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1701;}i:36;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1701;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:"빈 아이디, 이름, 별칭 : 빈 오브젝트를 구분할 수 있는 식별자";}i:2;i:1706;}i:38;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:82:"빈 아이디, 이름, 별칭 : 빈 오브젝트를 구분할 수 있는 식별자";}i:2;i:1706;}i:39;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:1788;}i:40;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:1788;}i:41;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1788;}i:42;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1788;}i:43;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:1788;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:101:"클래스 또는 클래스 이름 : 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보";}i:2;i:1793;}i:45;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:101:"클래스 또는 클래스 이름 : 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보";}i:2;i:1793;}i:46;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:1894;}i:47;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:1894;}i:48;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1894;}i:49;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1894;}i:50;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:1894;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:"스코프 : 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위";}i:2;i:1899;}i:52;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:86:"스코프 : 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위";}i:2;i:1899;}i:53;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:1985;}i:54;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:1985;}i:55;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1985;}i:56;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1985;}i:57;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:1985;}i:58;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:"프로퍼티 값 또는 참조 : DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름";}i:2;i:1990;}i:59;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:109:"프로퍼티 값 또는 참조 : DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름";}i:2;i:1990;}i:60;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2099;}i:61;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2099;}i:62;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2099;}i:63;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2099;}i:64;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:2099;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:"생성자 파라미터 값 또는 참조 : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름";}i:2;i:2104;}i:66;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:126:"생성자 파라미터 값 또는 참조 : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름";}i:2;i:2104;}i:67;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2230;}i:68;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2230;}i:69;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2230;}i:70;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2230;}i:71;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:2230;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"지연된 로딩 여부, 우선 빈 여부, 자동 와이어링 여부, 부모 빈 정보, 빈 팩토리 이름 등";}i:2;i:2235;}i:73;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:115:"지연된 로딩 여부, 우선 빈 여부, 자동 와이어링 여부, 부모 빈 정보, 빈 팩토리 이름 등";}i:2;i:2235;}i:74;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2350;}i:75;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2350;}i:76;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2350;}i:77;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:2350;}i:78;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2350;}i:79;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:467:"스프링 IoC 컨테이너는 각 빈에 대한 정보를 담은 설정 메타정보를 읽어들인 뒤에, 이름 참고해서 빈 오브젝트를 생성하고 프로퍼티나 생성자를 통해 의존 오브젝트를 주입해주는 DI 작업을 수행한다. 이 작업을 통해 만들어지고, DI로 연결되는 오브젝트들이 모여서 하나의 애플리케이션을 구성하고 동작하게 된다. IoC 컨테이너의 역할은 바로 이것이다. ";}i:2;i:2352;}i:80;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2820;}i:81;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:304:"메타정보 리소스 -> 메타정보 리더 -> 설정 메타 정보  -->  IOC 컨테이너              --> DI로 된 빈 오브젝트로 이루어진
                                  POJO클래스     -->  (애플리케이션 컨텍스트)    --> 어플리케이션
                                  ";}i:2;i:2820;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2820;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:443:"결국 스프링 애플리케이션이란 POJO 클래스와 설정 메타정보를 이용해 IoC 컨테이너가 만들어주는 오브젝트의 조합이라고 할 수 있다. 일반적으로 설정 메타정보는 XML 파일이나 애노테이션 같은 외부 리소스를 전용 리더가 읽어서 BeanDefinition 타입의 오브젝트로 만들어 사용한다. 원한다면 직접 BeanDefinition 메타정보를 생성할 수도 있다.";}i:2;i:3132;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3575;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3575;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:218:"IoC 컨테이너가 관리하는 빈은 오브젝트 단위지 클래스 단위가 아니라는 사실을 기억해야 한다. 경우에 따라서 하나의 클래스를 여러 개의 빈으로 등록하기도 한다. ";}i:2;i:3577;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3796;}i:88;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:333:"StaticApplicationContext ac = new StaticApplicationContext();
ac.registerSingleton("hello1", Hello.class);
Hello hello1 = ac.getBean("hello1", Hello.class);

BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);
";}i:2;i:3796;}i:89;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3796;}i:90;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:371:"IoC 컨테이너는 빈 설정 메타정보를 담은 BeanDefinition을 이용해 오브젝트를 생성하고 DI 작업을 진행한 뒤에 빈으로 사용할 수 있도록 등록해준다. 이때 BeanDefinition의 클래스, 프로퍼티, 빈 아이디 등의 정보가 활용된다. IoC 컨테이너에서 등록된 빈 설정 메타정보를 가져올 수도 있다.";}i:2;i:4147;}i:91;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4518;}i:92;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4518;}i:93;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:410:"빈에 DI되는 프로퍼티는 스트링이나 숫자 등의 값과, 다른 빈 오브젝트를 가리키는 레퍼런스로 구분할 수 있다. 레퍼런스로 지정된 프로퍼티는 다른 빈 오브젝트를 주입해서 오브젝트 사이의 관계를 만들어내는 데 사용된다. Hello 클래스와 StringPrinter 클래스는 아주 느슨하고 간접적인 관계를 맺고 있을 뿐이다.";}i:2;i:4520;}i:94;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4930;}i:95;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4930;}i:96;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:181:"이번에는 Hello 타입의 빈과 StringPrinter 타입의 빈을 hello와 printer라는 빈 이름으로 생성하고 printer빈이 hello 빈에게 DI 되도록 만들어 보자. ";}i:2;i:4932;}i:97;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5113;}i:98;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5115;}i:99;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:49:"1.1.2 IoC 컨테이너의 종류와 사용 방법";i:1;i:3;i:2;i:5115;}i:2;i:5115;}i:100;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5115;}i:101;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5175;}i:102;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"StaticApplicationContext";i:1;i:4;i:2;i:5175;}i:2;i:5175;}i:103;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:5175;}i:104;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5175;}i:105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:472:"StaticApplicationContext는 코드를 통해 빈 메타정보를 등록하기 위해 사용한다. 스프링의 기능에 대한 학습 테스트를 만들 때를 제외하면 실제로 사용되지 않는다. 그럼에도 이 클래스를 사용하는 코드를 살펴본 이유는 스프링 IoC컨테이너는 파일 폼새이나 리소스 종류에 독립적이며 오브젝트로 표현되는 순수한 메타정보를 사용한다는걸 보여주기 위해서였다. ";}i:2;i:5208;}i:106;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5681;}i:107;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5681;}i:108;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"GenericApplicationContext";i:1;i:4;i:2;i:5681;}i:2;i:5681;}i:109;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:5681;}i:110;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5681;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:297:"GenericApplicationContext는 가장 일반적인 애플리케이션 컨텍스트의 구현 클래스다. StaticApplicationContext와는 달리 XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리더를 통해 읽어들여서 메타정보로 전환해서 사용한다. ";}i:2;i:5715;}i:112;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6012;}i:113;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6014;}i:114;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"1.2.2 빈 등록 방법";i:1;i:3;i:2;i:6014;}i:2;i:6014;}i:115;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6014;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6014;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:380:"빈 등록은 빈 메타정보를 작성해서 컨테이너에게 건네주면 된다. 가장 직접적이고 원시적인 방법은 BeanDefinition 구현 오브젝트를 직접 생성하는 것이다. 하지만 스프링을 확장해서 프레임워크를 만들거나 스프링의 내부 동작원리를 학습하려는 게 목적이 아니라면 이 방법은 무리가 있다.";}i:2;i:6048;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6428;}i:119;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6428;}i:120;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:294:"그래서 보통 XML 문서, 프로퍼티 파일, 소스코드 애노테이션과 같은 외부 리소스로 빈 메타정보를 작성하고 이를 적절한 리더나 변환기를 통해 애플리케이션 컨텍스트가 사용할 수 있는 정보로 변환해주는 방법을 사용한다.";}i:2;i:6430;}i:121;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6724;}i:122;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6724;}i:123;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"스프링에서 자주 사용되는 빈의 등록 방법은 크게 다섯 가지가 있다.";}i:2;i:6726;}i:124;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6818;}i:125;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6818;}i:126;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6818;}i:127;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6818;}i:128;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6818;}i:129;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"XML : <bean> 태그";}i:2;i:6823;}i:130;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:19:"XML : <bean> 태그";}i:2;i:6823;}i:131;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:6842;}i:132;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:6842;}i:133;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6842;}i:134;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6842;}i:135;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:6842;}i:136;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:"XML : 네임스페이스와 전용 태그";}i:2;i:6847;}i:137;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:41:"XML : 네임스페이스와 전용 태그";}i:2;i:6847;}i:138;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:6888;}i:139;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:6888;}i:140;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:6888;}i:141;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:6888;}i:142;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6890;}i:143;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:90:"자동인식을 이용한 빈 등록 : 스테레오타입 애노테이션과 빈 스캐너";i:1;i:4;i:2;i:6890;}i:2;i:6890;}i:144;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:6890;}i:145;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6890;}i:146;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:554:"XML 문서와 같이 한곳에 명시적으로 선언하지 않고도 스프링 빈을 등록하는 방법이 있다. 빈으로 사용될 클래스에 특별한 애노테이션ㅇ르 부여해주면 이런 클래스를 자동으로 찾아서 빈으로 등록해주게 할 수 있다. 이렇게 특정 애노테이션이 붙은 클래스를 자동으로 찾아서 빈으로 등록해주는 방식을 빈 스캐닝을 통한 자동인식 빈 등록 기능이라고 하고, 이런 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너라고 한다.";}i:2;i:6989;}i:147;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7543;}i:148;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7543;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:664:"스프링의 빈 스캐너는 지정된 클래스패스 아래에 있는 모든 패키지의 클래스를 대상으로 필터를 적용해서 빈 등록을 위한 클래스들을 선별해낸다. 빈 스캐너에 내장된 디폴트 필터는 @Component 애노테이션 또는 @Component를 메타 애노테이션으로 가진 애노테이션이 부여된 클래스를 선택하도록 되어 있다. 이를 이용하면 @Component 등의 애노테이션을 지정하는 것만으로도 빈 등록이 가능하다. @Component를 포함해 디폴트 필터에 적용되는 애노테이션을 스프링에서는 스테레오 타입 애노테이션이라고 부른다.";}i:2;i:7545;}i:150;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8209;}i:151;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8209;}i:152;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:697:"개발 중에는 생산성을 위해 빈 스캐닝 기능을 사용해서 빈을 등록하지만, 개발이 어느 정도 마무리되고 세밀한 관리와 제어가 필요한 운영 시점이 되면 다시 XML 형태의 빈 선언을 적용하는 것도 좋은 전략이다. 빈 등록을 위한 스캐닝 작업은 지정된 클래스패스 안의 모든 클래스에 대해 필터를 적용하는 방법으로 진행된다. 이때 빈 스캐너의 필터를 변경하거나 정규식 같은 이름 패턴을 이용해서 빈으로 등록할 클래스를 선정하게 할 수 있다. 자동인식을 통한 빈 등록을 사용하려면 다음 두 가지 방법 중 하나를 쓰면 도니다.";}i:2;i:8211;}i:153;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8909;}i:154;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:8909;}i:155;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:8909;}i:156;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:8909;}i:157;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:8909;}i:158;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"XML을 이용한 빈 스캐너 등록";}i:2;i:8914;}i:159;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:37:"XML을 이용한 빈 스캐너 등록";}i:2;i:8914;}i:160;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:8951;}i:161;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:8951;}i:162;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:8951;}i:163;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:8951;}i:164;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:8951;}i:165;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:"빈 스캐너를 내장한 애플리케이션 컨텍스트 사용";}i:2;i:8956;}i:166;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:65:"빈 스캐너를 내장한 애플리케이션 컨텍스트 사용";}i:2;i:8956;}i:167;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:9021;}i:168;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:9021;}i:169;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:9021;}i:170;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:9021;}i:171;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9021;}i:172;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:9021;}}