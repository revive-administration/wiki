a:58:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"Chapter 06 싱글턴 패턴";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:43;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"6.1 프린터 관리자 만들기";i:1;i:2;i:2;i:43;}i:2;i:43;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:43;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:278:"Printer 클래스의 생성자를 private으로 선언하면 외부에서는 new Printer()를 더 사용할 수 없게 된다. 그러나 하나의 인스턴스는 만들어야 되는 상황이므로 이 인스턴스를 만들어 외부에 제공해줄 메서드가 필요하다.";}i:2;i:89;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:368;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:368;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"6.2 문제점";i:1;i:2;i:2;i:368;}i:2;i:368;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:368;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:368;}i:13;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:394;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" 경합 조건(race condition) ";}i:2;i:396;}i:15;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:427;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:" : 메모리와 같은 동일한 자원을 2개 이상의 스레드가 이용하려고 경합하려는 현상";}i:2;i:429;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:538;}i:18;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:540;}i:19;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"6.3 해결책";i:1;i:2;i:2;i:540;}i:2;i:540;}i:20;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:540;}i:21;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:540;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:"다중 스레드 애플리케이션에서 발생하는 문제를 해결하는 방법 2가지를 설명한다.";}i:2;i:566;}i:23;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:676;}i:24;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:676;}i:25;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:676;}i:26;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:676;}i:27;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:676;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"정적 변수에 인스턴스를 만들어 바로 초기화하는 방법";}i:2;i:681;}i:29;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:72:"정적 변수에 인스턴스를 만들어 바로 초기화하는 방법";}i:2;i:681;}i:30;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:753;}i:31;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:753;}i:32;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:753;}i:33;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:753;}i:34;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:753;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"인스턴스를 만드는 메서드에 동기화하는 방법";}i:2;i:758;}i:36;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:61:"인스턴스를 만드는 메서드에 동기화하는 방법";}i:2;i:758;}i:37;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:819;}i:38;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:819;}i:39;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:819;}i:40;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:819;}i:41;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:821;}i:42;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"6.4 싱글턴 패턴";i:1;i:2;i:2;i:821;}i:2;i:821;}i:43;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:821;}i:44;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:821;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:301:"싱글턴 패턴은 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 이 인스턴스에 접근할 수 있도록 하는 디자인 패턴이다. 원래 싱글턴이라는 단어는 '단 하나의 원소만을 가진 집합'이라는 수학 이론에서 유래되었다.";}i:2;i:854;}i:46;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1155;}i:47;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1157;}i:48;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:40:"6.5 싱글턴 패턴과 정적 클래스";i:1;i:2;i:2;i:1157;}i:2;i:1157;}i:49;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1157;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1157;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:164:"실제로 굳이 싱글턴 패턴을 사용하지 않고 정적 메서드로만 이루어진 정적 클래스를 사용해도 동일한 효과를 얻을 수 있다.";}i:2;i:1208;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1372;}i:53;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1372;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:394:"정적 클래스를 이용하는 방법이 싱글턴 패턴을 이용하는 방법과 가장 차이가 나는 점은 객체를 전혀 생성하지 않고 메서드를 사용한다는 점이다. 더욱이 정적 메서드를 사용하므로 성능 면에서 더 우수하다. 그러나 인터페이스를 구현해야 하는 경우 정적 메서드는 인터페이스에서 사용할 수 없다.";}i:2;i:1374;}i:55;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1768;}i:56;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1768;}i:57;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:1768;}}