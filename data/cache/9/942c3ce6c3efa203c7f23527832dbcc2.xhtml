
<h1 class="sectionedit1" id="chapter_11_인덱싱과_해싱">Chapter 11 인덱싱과 해싱</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Chapter 11 인덱싱과 해싱" [1-45] -->
<h2 class="sectionedit2" id="기본_개념">11.1 기본 개념</h2>
<div class="level2">

<p>
인덱스에 두 가지 기본적인 종류가 있다.
</p>
<ul>
<li class="level1"><div class="li"> 순서 인덱스(Ordered index) : 값에 대해 정렬된 순서로 되어 있다.</div>
</li>
<li class="level1"><div class="li"> 해시 인덱스(Hash index) : 버켓의 범위 안에서 값이 일정하게 분배로 되어 있다. 값이 할당되는 버켓은 해시 함수에 의해 결정된다. </div>
</li>
</ul>

<p>
각 기술은 다음과 같은 요소에 기초해서 평가되어야 한다.
</p>
<ul>
<li class="level1"><div class="li"> 액세스 형태(Access type) : 효율적으로 지원되는 액세스 형태. 액세스 형태는 특정한 속성의 값을 가진 레코드나 특정한 범위에 들어가는 속성의 값을 가지는 레코드를 찾는 것을 포함한다.</div>
</li>
<li class="level1"><div class="li"> 액세스 시간(Access time) : 쟁점이 되는 기술을 사용해서 특정한 데이터 항목이나 항목의 집합을 찾는 데 걸리는 시간</div>
</li>
<li class="level1"><div class="li"> 삽입 시간(Insertion time)</div>
</li>
<li class="level1"><div class="li"> 삭제 시간(Deletion time)</div>
</li>
<li class="level1"><div class="li"> 공간 부담(Space overhead) : 인덱스 구조에 의해 사용되어지는 부가적인 공간</div>
</li>
</ul>

</div>
<!-- EDIT2 SECTION "11.1 기본 개념" [46-1050] -->
<h2 class="sectionedit3" id="순서_인덱스">11.2 순서 인덱스</h2>
<div class="level2">

<p>
파일은 서로 다른 검색 키에 따라 몇몇 인덱스를 갖고 있다. 레코드를 포함하는 파일이 연속적인 순서로 되어 있다면 클러스터링 인덱스(clustering index)는 그 파일을 연속적인 순서로 정의한 속성을 검색 키로 사용하는 인덱스이다. 클러스터링 인덱스는 또한 주 인덱스(primary index)로도 불린다. 검색 키에 대해 주 인덱스를 가지는 위와 같은 파일을 인덱스-순차 파일(index-sequential files)이라 부른다. 
</p>

</div>
<!-- EDIT3 SECTION "11.2 순서 인덱스" [1051-1608] -->
<h3 class="sectionedit4" id="밀집과_희소_인덱스">11.2.1 밀집과 희소 인덱스</h3>
<div class="level3">

<p>
인덱스 레코드(index record) 즉, 인덱스 엔트리(index entry)는 검색 키 값과 포인터로 구성되어 있는데 이때 포인터는 이것을 검색 키 값으로 가지는 한개 이상의 레코드에 대한 포인터이다. 레코드에 대한 포인터는 디스크 블록의 식별자와 블록 안에서 레코드를 구별하기 위한 디스크 블록 안에서의 오프셋으로 구성되어 있다. 
</p>

<p>
우리가 사용할 수 있는 순서 인덱스는 두 가지 형태가 있다.
</p>
<ul>
<li class="level1"><div class="li"> 밀집 인덱스(Dense index) : 밀집 인덱스에서 인덱스 엔트리는 파일에 있는 모든 검색 키 값에 대해 나타난다. 밀집 클러스터링 인덱스에서 인덱스 레코드는 검색 키 값과 그 검색 키 값의 첫 번째 레코드에 대한 포인터를 포함한다. 똑같은 검색 키 값을 가진 나머지 레코드들은 첫 번째 레코드 이후부터 연속적으로 저장되는데 이는 인덱스가 클러스터링 인덱스여서 이런 레코드들은 동일한 검색 키로 정렬되기 때문이다. 밀집 비클러스터링 인덱스에서 인덱스는 똑같은 검색 키를 가진 모든 레코드들에 대한 포인터 목록을 저장해야 한다.</div>
</li>
<li class="level1"><div class="li"> 희소 인덱스(Sparse index) : 희소 인덱스에서 인덱스 엔트리는 검색 키 값에 대해 단지 몇개만 나타난다. 희소 인덱스는 오직 릴레이션이 검색 키로 정렬되어 저장될 때, 즉 인덱스가 클러스터링 인덱스인 경우 사용될 수 있다.</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "11.2.1 밀집과 희소 인덱스" [1609-3177] -->
<h3 class="sectionedit5" id="다단계_인덱스">11.2.2 다단계 인덱스</h3>
<div class="level3">

<p>
인덱스를 다른 순차파일처럼 취급해서 내부인덱스라고 불리는 원래의 주 인덱스에 대한 희소 외부 인덱스를 구성한다. 인덱스 엔트리는 외부 인덱스를 희소하게 분포시키며 항상 정렬된 순서로 존재한다. 레코드의 위치를 찾기 위해 먼저 외부 인덱스 상에서 이진 검색을 이용해서 원하는 레코드보다 작거나 같은 검색 키 값 중에서 가장 큰 값을 가지는 레코드를 찾을 수 있다. 이때의 레코드 포인터는 내부 인데긋 블록을 가리킨다. 이 포인터가 가리키는 블록을 스캔하여 원하는 레코드보다 작거나 같은 검색 키 값 중에서 가장 큰 값을 가지는 레코드를 찾는다. 
</p>

</div>
<!-- EDIT5 SECTION "11.2.2 다단계 인덱스" [3178-3964] -->
<h3 class="sectionedit6" id="인덱스_갱신">11.2.3 인덱스 갱신</h3>
<div class="level3">

<p>
사용되는 인덱스의 형태와 상관없이 모든 인덱스는 어떤 레코드가 파일에 삽입되거나 파일로부터 삭제될 때마다 갱신되어야 한다.
</p>
<ul>
<li class="level1"><div class="li"> 삽입(Insertion) : 먼저 시스템은 삽입되는 레코드의 검색 키 값을 사용해서 찾기를 수행한다. </div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "11.2.3 인덱스 갱신" [3965-4300] -->
<h3 class="sectionedit7" id="차_인덱스">11.2.4 2차 인덱스</h3>
<div class="level3">

<p>
2차인덱스는 모든 검색 키 값과 모든 레코드에 대한 포인터를 가지는 인덱스 엔트리로 된 밀집인덱스여야 한다. 
</p>

</div>
<!-- EDIT7 SECTION "11.2.4 2차 인덱스" [4301-4483] -->
<h3 class="sectionedit8" id="다중_키_상의_인덱스">11.2.5 다중 키 상의 인덱스</h3>
<div class="level3">

<p>
두 개 이상의 속성들로 구성된 검색 키를 복합 검색 키라한다. 이 인덱스의 구조는 모두 다른 인덱스의 구조와 같고, 유일한 차이점은 검색 키가 하나의 속성이 아니라 속성들의 목록으로 되어 있다는 것이다. 
</p>

</div>
<!-- EDIT8 SECTION "11.2.5 다중 키 상의 인덱스" [4484-4806] -->
<h2 class="sectionedit9" id="b_트리_인덱스_파일">11.3 B+ 트리 인덱스 파일</h2>
<div class="level2">

</div>
<!-- EDIT9 SECTION "11.3 B+ 트리 인덱스 파일" [4807-4849] -->
<h3 class="sectionedit10" id="b_트리의_구조">11.3.1 B+ 트리의 구조</h3>
<div class="level3">

<p>
노드 안의 검색 키 값은 정렬된 순서로 유지된다. 단말 노드의 구조를 생각해보자 i=1,2,3,…,n-1일 때 포인터 Pi는 검색 키 값 Ki를 가지는 파일 레코드를 가리킨다. 각 단말 노드는 n - 1 개까지의 값을 가질 수 있는데 단말 노드는 적어도 [(n-1)/2] 개의 값을 포함해야 한다. B+ 트리의 비단말 노드는 단말 노드 상에서 다단계 (희소)인덱스를 형성한다. 비단말 노드의 구조는 모든 포인터가 트리 노드에 대한 포인터인 것을 제외하고는 단말 노드의 구조와 동일하다. 비단말 노드는 n개까지의 포인터를 가질 수 있고 적어도 [n/2]개의 포인터를 갖고 있어야 한다. 한 노드의 포인터 수를 그 노드의 팬아웃이라 부른다. 
</p>

</div>
<!-- EDIT10 SECTION "11.3.1 B+ 트리의 구조" [4850-5691] -->
<h3 class="sectionedit11" id="비유일_검색_키">11.3.4 비유일 검색 키</h3>
<div class="level3">

<p>
만약 릴레이션이 같은 검색 키 값(즉, 2개 혹은 그 이상의 레코드가 인덱스된 속성에 대해 같은 값을 가질 수 있다.)을 포함하는 레코드가 한 개 이상이라면 검색 키는 비유일 검색 키(nonunique search key)라고 불린다. 비유일 키의 한 가지 문제점은 레코드 삭제의 비효율성이다. 특정 키 값이 여러 번 발생하고 그 검색 키 값을 가지는 레코드들 중에 한 레코드가 삭제된다고 생각해보자. 삭제는 삭제되어질 특정 레코드와 일치하는 엔트리를 찾기 위해 잠재적으로 여러 개의 단말 노드인 수많은 엔트리를 검색해야 한다.
</p>

<p>
대부분의 데이터베이스 시스템들이 이에 대한 간단한 해결책으로 검색 키에 원래의 검색 키와 모든 레코드들에게서 유일하게 나타나는 다른 속성을 포함하는 복합 검색 키를 만드는 방법을 사용한다. 별도의 속성으로는 레코드에 대한 포인터인 레코드 id 혹은 같은 검색 키를 가진 모든 레코드들에서 유일한 값을 가지는 다른 속성이 될 수 있다. 부가적인 속성은 유일 식별자(uniquifier) 속성이라고 불린다. 레코드가 삭제될 때 복합 검색 키 값은 레코드로부터 게산되며 그 후에 인덱스를 찾기 위해 사용된다. 값이 유일하기 때문에 일치하는 단말 레벨 엔트리는 추가적인 단말 레벨의 엑세스 없이도 루트에서 단말 노드까지 단 한번의 탐색으로 발견되다. 
</p>

</div>
<!-- EDIT11 SECTION "11.3.4 비유일 검색 키" [5692-7282] -->
<h2 class="sectionedit12" id="b_트리_확장">11.4 B+ 트리 확장</h2>
<div class="level2">

</div>
<!-- EDIT12 SECTION "11.4 B+ 트리 확장" [7283-7316] -->
<h3 class="sectionedit13" id="b_트리의_파일_구조">11.4.1 B+ 트리의 파일 구조</h3>
<div class="level3">

<p>
인덱스 순차 파일 구조의 주요 단점은 파일이 커지면서 성능이 감소하는 것이다. 인덱스 뿐만 아니라 파일에 있는 레코드를 위한 구조도 B+ 트리 구조를 이용할 수 있다. B+ 트리 파일 구조에서 트리의 단말 노드는 레코드에 대한 포인터를 저장하는 대신에 레코드를 저장한다. 레코드는 보통 포인터보다 더 크기 때문에 단말 노드에 저장될 수 있는 레코드의 최대 개수는 비단말 노드에 저장되는 포인터의 개수보다 더 적다. 그러나 단말 노드는 여전히 적어도 반은 차야한다.
</p>

</div>
<!-- EDIT13 SECTION "11.4.1 B+ 트리의 파일 구조" [7317-7988] -->
<h3 class="sectionedit14" id="차_인덱스와_레코드_재배치">11.4.2 2차 인덱스와 레코드 재배치</h3>
<div class="level3">

<p>
B+ 트리 파일 구조에서 단말 노드가 분할될 때 여러 레코드들이 새로운 페이지로 이동한다. 이 경우 레코드 안의 값들은 바뀌지 않았더라도 재배치된 레코드들에 대한 포인터가 저장된 2차 인덱스들은 전부 갱신되어야 한다. 이러한 문제를 해결하기 위해 많이 사용되는 방법은 다음과 같다. 2차 인덱스에 레코드들에 대한 포인터 대신 주 인덱스 검색 키 속성의 값들을 저장한다. 이렇게 하면 레코드 재배치가 일어나도 2차 인덱스는 갱신될 필요가 없다. 그러나 2차 인덱스를 이용하여 특정 레코드를 찾기 위해 두 단계를 거쳐야 한다. 
</p>

</div>
<!-- EDIT14 SECTION "11.4.2 2차 인덱스와 레코드 재배치" [7989-8751] -->
<h3 class="sectionedit15" id="문자열_인덱싱">11.4.3 문자열 인덱싱</h3>
<div class="level3">

<p>
문자열 값을 갖는 속성들에 대해 B+ 트리 인덱스를 생성하는 것은 두 가지 문제를 야기한다. 첫 번째 문제는 문자열이 가변 길이를 가질 수 있다는 것이다. 두 번째 문제는 문자열이 길 경우 팬아웃이 적어지고 따라서 트리 높이가 증가한다는 것이다. 접두어 압축(prefix compression)이라는 기술을 이용해 노드의 팬아웃을 늘릴 수 있다. 접두어 압축을 이용하면 내부 노드에 검색 키 전체를 저장할 필요가 없다. 즉, 하위 트리들과 구별하는데 충분한 만큼의 접두어를 검색 키에서 취해 저장한다. 
</p>

</div>
<!-- EDIT15 SECTION "11.4.3 문자열 인덱싱" [8752-9438] -->
<h3 class="sectionedit16" id="b_트리_인덱스의_벌크_로딩_bulk_loading">11.4.4 B+ 트리 인덱스의 벌크 로딩(Bulk Loading)</h3>
<div class="level3">

<p>
대용량의 엔트리를 한번에 인덱스에 삽입하는 것을 인덱스의 벌크 로딩(bulk loading)이라 한다. 우선 릴레이션의 인덱스 엔트리를 포함하는 임시 파일을 생성한다. 그 이후에 구축되는 인덱스의 검색 키에 대해 파일을 정렬하고 마지막으로 정렬된 파일을 스캔하고 엔트리를 인덱스에 삽입한다. 
</p>

</div>
<!-- EDIT16 SECTION "11.4.4 B+ 트리 인덱스의 벌크 로딩(Bulk Loading)" [9439-9894] -->
<h3 class="sectionedit17" id="b-트리_인덱스_파일">11.4.5 B-트리 인덱스 파일</h3>
<div class="level3">

<p>
B-트리의 공간 이득은 큰 인덱스에서는 별 이득이 되지 못하고, 주목했던 단점을 능가하지 못한다.
</p>

</div>
<!-- EDIT17 SECTION "11.4.5 B-트리 인덱스 파일" [9895-10069] -->
<h3 class="sectionedit18" id="플래시_메모리">11.4.6 플래시 메모리</h3>
<div class="level3">

</div>
<!-- EDIT18 SECTION "11.4.6 플래시 메모리" [10070-10107] -->
<h2 class="sectionedit19" id="다중_키_액세스">11.5 다중 키 액세스</h2>
<div class="level2">

</div>
<!-- EDIT19 SECTION "11.5 다중 키 액세스" [10108-10145] -->
<h3 class="sectionedit20" id="다중키_상의_인덱스">11.5.2 다중키 상의 인덱스</h3>
<div class="level3">

<p>
A와 B는 많지만 A와 B의 교집합이 적을때의 대안으로 복합 검색키에 대해 인덱스를 생성해서 이용할 수 있다. 검색키에 대한 순서 인덱스를 사용하면 한속성에 대한 동등 조건만 있는 질의도 효율적으로 처리할 수 있다. 그러나 비교의 경우 다른 디스크 블록 문제, 레코드 순서 문제 때문에 io가 발생할 수 있다.
</p>

</div>
<!-- EDIT20 SECTION "11.5.2 다중키 상의 인덱스" [10146-10599] -->
<h3 class="sectionedit21" id="커버링_인덱스">11.5.3 커버링 인덱스</h3>
<div class="level3">

</div>
<!-- EDIT21 SECTION "11.5.3 커버링 인덱스" [10600-10636] -->
<h2 class="sectionedit22" id="정적_해싱">11.6 정적 해싱</h2>
<div class="level2">

</div>
<!-- EDIT22 SECTION "11.6 정적 해싱" [10637-10669] -->
<h3 class="sectionedit23" id="다중_단일_키_인덱스_사용">11.5.1 다중 단일 키 인덱스 사용</h3>
<div class="level3">

<p>
의례적으로 K는 모든 검색 키 값의 집합을 나타내고, B는 모든 버켓 주소의 집합을 나타낸다. 해시 함수 h는 K를 B에 대응시키는 함수이다. h는 해시함수를 나타낸다. 
</p>

<p>
검색키 Ki를 찾기 위해 h(Ki)를 계산해서 이 레코드를 위한 버켓 주소를 구한다. 이 때 레코드를 저장하기 위한 공간이 버켓에 있다고 가정한다. 그 다음 이 레코드를 그 버켓에 저장한다.
</p>

<p>
서로 다른 두 가지 목적으로 해싱을 사용할 수 있다. 해시 파일 구조는 레코드의 검색 키 값에 대한 함수 계산을 통해 원하는 레코드를 가진 디스크 블록의 주소를 직접 얻을 수 있도록 해준다. 해시 인덱스 구조는 검색 키들과 관련된 포인터들을 해시 파일 구조로 조직화할 수 있게 해준다.
</p>

</div>
<!-- EDIT23 SECTION "11.5.1 다중 단일 키 인덱스 사용" [10670-11571] -->
<h3 class="sectionedit24" id="해시_인덱스">11.6.3 해시 인덱스</h3>
<div class="level3">

<p>
해싱은 파일 구조뿐만 아니라 인덱스 구조 생성에도 사용될 수 있다. 해시 인덱스(hash index)는 검색 키, 이와 연관된 포인터를 해시 파일 구조 안에 구성한다.
</p>

</div>
<!-- EDIT24 SECTION "11.6.3 해시 인덱스" [11572-11814] -->
<h3 class="sectionedit25" id="데이터_구조">11.7.1 데이터 구조</h3>
<div class="level3">

<p>
확장성 해싱은 데이터베이스가 증대하고 축소함에 따라 버켓을 분할하고 유착시킴으로써 데이터베이스 크기의 변화를 대처한다. 결과적으로 공간 효율성이 유지된다. 또한 파일의 재구성은 한번에 하나의 버켓에서만 수행되기 때문에 성능 부담은 비교적 낮다.
</p>

</div>
<!-- EDIT25 SECTION "11.7.1 데이터 구조" [11815-12196] -->
<h3 class="sectionedit26" id="질의와_갱신">11.7.2 질의와 갱신</h3>
<div class="level3">

<p>
모르겠음(확장성 해싱)
</p>

</div>
<!-- EDIT26 SECTION "11.7.2 질의와 갱신" [12197-12261] -->
<h2 class="sectionedit27" id="비트맵_인덱스">11.9 비트맵 인덱스</h2>
<div class="level2">

<p>
비트맵 인덱스를 사용하기 위해 릴레이션에 있는 레코드는 0부터 시작해서 연속적으로 번호가 매겨져야 한다. 숫자 n이 주어지면 n으로 번호 매겨진 레코드를 검색하기가 쉬워야 한다. 특히 레코드의 크기가 고정되어 있고 파일의 연속적인 블록에 할당되어 있다면 이는 쉽게 달성된다. 레코드는 쉽게 블록 번호와 블록 안에서 레코드를 식별하는 번호로 전환될 수 있다. 
</p>

</div>
<!-- EDIT27 SECTION "11.9 비트맵 인덱스" [12262-12790] -->
<h3 class="sectionedit28" id="비트맵_인덱스_구조">11.9.1 비트맵 인덱스 구조</h3>
<div class="level3">

<p>
비트맵은 간단한 비트 배열이다. 가잔 간단한 형태로, 릴레이션 r의 속성 A상의 비트맵 인덱스는 A가 가질 수 있는 각 값에 대해 하나의 비트맵을 구성한다. 각 비트맵은 릴레이션에 있는 레코드의 수만큼 많은 비트를 가지고 있다. 만약 번호가 i인 레코드의 속성 A가 vj 값을 가지고 있다면, 값 vj를 위해 비트맵의 i번째 비트를 1로 설정한다. m에 대한 비트맵의 모든 다른 비트는 0으로 설정한다. 비슷하게 f에 대한 비트맵은 gender 속성의 값을 f로 가지는 레코드에 대한 비트는 1의 값을 가지고 나머지 모든 비트는 0의 값을 가진다. 
</p>

</div>
<!-- EDIT28 SECTION "11.9.1 비트맵 인덱스 구조" [12791-13535] -->
<h3 class="sectionedit29" id="비트맵과_b_트리">11.9.3 비트맵과 B+ 트리</h3>
<div class="level3">

</div>
<!-- EDIT29 SECTION "11.9.3 비트맵과 B+ 트리" [13536-] -->