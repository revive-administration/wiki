
<h1 class="sectionedit1" id="gof_디자인_패턴">GoF 디자인 패턴</h1>
<div class="level1">

<p>
이 패턴의 목차는 &#039;GoF의 디자인 패턴&#039;을 기준으로 함
</p>

</div>
<!-- EDIT1 SECTION "GoF 디자인 패턴" [1-105] -->
<h2 class="sectionedit2" id="생성_패턴_creational_patterns">생성 패턴(Creational Patterns)</h2>
<div class="level2">

</div>
<!-- EDIT2 SECTION "생성 패턴(Creational Patterns)" [106-151] -->
<h3 class="sectionedit3" id="추상_팩토리_abstract_factory_패턴">추상 팩토리(Abstract Factory) 패턴</h3>
<div class="level3">
<pre class="code">구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 
서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴이다.</pre>

</div>
<!-- EDIT3 SECTION "추상 팩토리(Abstract Factory) 패턴" [152-421] -->
<h3 class="sectionedit4" id="빌더_builder_패턴">빌더(Builder) 패턴</h3>
<div class="level3">
<pre class="code">복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서
서로 다른 표현 결과를 만들 수 있게 하는 패턴이다.</pre>

</div>
<!-- EDIT4 SECTION "빌더(Builder) 패턴" [422-621] -->
<h3 class="sectionedit5" id="팩토리_메서드_factory_method_패턴">팩토리 메서드(Factory Method) 패턴</h3>
<div class="level3">
<pre class="code">객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 
서브 클래스 쪽에서 내리는 패턴이다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 
만드는 시점을 서브 클래스로 미룬다.</pre>

</div>
<!-- EDIT5 SECTION "팩토리 메서드(Factory Method) 패턴" [622-957] -->
<h3 class="sectionedit6" id="원형_prototype_패턴">원형(Prototype) 패턴</h3>
<div class="level3">
<pre class="code">생성할 객체의 종류를 명세하는 데에 원형이 되는 예시물을 이용하고, 
그 원형을 복사함으로써 새로운 객체를 생성하는 패턴이다.</pre>

</div>
<!-- EDIT6 SECTION "원형(Prototype) 패턴" [958-1170] -->
<h3 class="sectionedit7" id="단일체_singleton_패턴">단일체(Singleton) 패턴</h3>
<div class="level3">
<pre class="code">어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 
전역적인 접촉적을 제공하는 패턴이다.</pre>

</div>
<!-- EDIT7 SECTION "단일체(Singleton) 패턴" [1171-1381] -->
<h2 class="sectionedit8" id="구조_패턴_structural_patterns">구조 패턴(Structural Patterns)</h2>
<div class="level2">

</div>
<!-- EDIT8 SECTION "구조 패턴(Structural Patterns)" [1382-1427] -->
<h3 class="sectionedit9" id="적응자_adapter_패턴">적응자(Adapter) 패턴</h3>
<div class="level3">
<pre class="code">클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 
호환성이 없는 인터페이스 대문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 준다.</pre>

</div>
<!-- EDIT9 SECTION "적응자(Adapter) 패턴" [1428-1702] -->
<h3 class="sectionedit10" id="가교_bridge_패턴">가교(Bridge) 패턴</h3>
<div class="level3">
<pre class="code">구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.</pre>

</div>
<!-- EDIT10 SECTION "가교(Bridge) 패턴" [1703-1841] -->
<h3 class="sectionedit11" id="복합체_composite_패턴">복합체(Composite) 패턴</h3>
<div class="level3">
<pre class="code">객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로,
사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 함</pre>

</div>
<!-- EDIT11 SECTION "복합체(Composite) 패턴" [1842-2066] -->
<h3 class="sectionedit12" id="장식자_decorator_패턴">장식자(Decorator) 패턴</h3>
<div class="level3">
<pre class="code">주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로,
기능 확장이 필요할 때 서브 클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다.</pre>

</div>
<!-- EDIT12 SECTION "장식자(Decorator) 패턴" [2067-2304] -->
<h3 class="sectionedit13" id="퍼사드_facade_패턴">퍼사드(Facade) 패턴</h3>
<div class="level3">
<pre class="code">서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로,
서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의함.</pre>

</div>
<!-- EDIT13 SECTION "퍼사드(Facade) 패턴" [2305-2575] -->
<h3 class="sectionedit14" id="플라이급_flyweight_패턴">플라이급(Flyweight) 패턴</h3>
<div class="level3">
<pre class="code">크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴이다.</pre>

</div>
<!-- EDIT14 SECTION "플라이급(Flyweight) 패턴" [2576-2736] -->
<h3 class="sectionedit15" id="프록시_proxy_패턴">프록시(Proxy) 패턴</h3>
<div class="level3">
<pre class="code">어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate) 또는
자리채움자(placeholder)를 제공하는 패턴이다.</pre>

</div>
<!-- EDIT15 SECTION "프록시(Proxy) 패턴" [2737-2942] -->
<h2 class="sectionedit16" id="행동_패턴_behavioral_patterns">행동 패턴(Behavioral Patterns)</h2>
<div class="level2">

</div>
<!-- EDIT16 SECTION "행동 패턴(Behavioral Patterns)" [2943-2989] -->
<h3 class="sectionedit17" id="책임_연쇄_chain_of_responsibility_패턴">책임 연쇄(Chain of Responsibility) 패턴</h3>
<div class="level3">
<pre class="code">요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 
객체 사이의 결합을 피하는 패턴이다. 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 
처리할 수 있는 객체를 만날 때까지 객체 고리를 따라서 요청을 전달한다.</pre>

</div>
<!-- EDIT17 SECTION "책임 연쇄(Chain of Responsibility) 패턴" [2990-3415] -->
<h3 class="sectionedit18" id="명령_command_패턴">명령(Command) 패턴</h3>
<div class="level3">
<pre class="code">요청을 객체-의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅,
그리고 연산의 취소를 지원하게 만드는 패턴이다.</pre>

</div>
<!-- EDIT18 SECTION "명령(Command) 패턴" [3416-3647] -->
<h3 class="sectionedit19" id="해석자_interpreter_패턴">해석자(Interpreter) 패턴</h3>
<div class="level3">
<pre class="code">주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 아울러 그 표현 수단을 
사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴이다.</pre>

</div>
<!-- EDIT19 SECTION "해석자(Interpreter) 패턴" [3648-3915] -->
<h3 class="sectionedit20" id="반복자_iterator_패턴">반복자(Iterator) 패턴</h3>
<div class="level3">
<pre class="code">내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는
방법을 제공하는 패턴이다.</pre>

</div>
<!-- EDIT20 SECTION "반복자(Iterator) 패턴" [3916-4113] -->
<h3 class="sectionedit21" id="중재자_mediator_패턴">중재자(Mediator) 패턴</h3>
<div class="level3">
<pre class="code">한 집합에 속해 있는 객체들의 상호작용을 캡슐화하는 객체를 정의한는 패턴이다. 객체들이
직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진시키며,
개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만든다.</pre>

</div>
<!-- EDIT21 SECTION "중재자(Mediator) 패턴" [4114-4493] -->
<h3 class="sectionedit22" id="메멘토_memento_패턴">메멘토(Memento) 패턴</h3>
<div class="level3">
<pre class="code">캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가
그 상태로 되돌아올 수 있도록 하는 패턴이다.</pre>

</div>
<!-- EDIT22 SECTION "메멘토(Memento) 패턴" [4494-4725] -->
<h3 class="sectionedit23" id="감시자_observer_패턴">감시자(Observer) 패턴</h3>
<div class="level3">
<pre class="code">객체들 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체의 의존성을
가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴이다.</pre>

</div>
<!-- EDIT23 SECTION "감시자(Observer) 패턴" [4726-5012] -->
<h3 class="sectionedit24" id="상태_state_패턴">상태(State) 패턴</h3>
<div class="level3">
<pre class="code">객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는
마치 자신의 클래스를 바꾸는 것처럼 보인다.</pre>

</div>
<!-- EDIT24 SECTION "상태(State) 패턴" [5013-5239] -->
<h3 class="sectionedit25" id="전략_strategy_패턴">전략(Strategy) 패턴</h3>
<div class="level3">
<pre class="code">동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화 하여, 이들을 상호 교환이 가능하도록
만드는 패턴이다. 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즙을 다양하게 변경할 수
있도록 한다.</pre>

</div>
<!-- EDIT25 SECTION "전략(Strategy) 패턴" [5240-5571] -->
<h3 class="sectionedit26" id="템플릿_메서드_template_method_패턴">템플릿 메서드(Template Method) 패턴</h3>
<div class="level3">
<pre class="code">객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로
미루는 패턴이다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서
재정의할 수 있게 한다.</pre>

</div>
<!-- EDIT26 SECTION "템플릿 메서드(Template Method) 패턴" [5572-5937] -->
<h3 class="sectionedit27" id="방문자_visitor_패턴">방문자(Visitor) 패턴</h3>
<div class="level3">
<pre class="code">객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 클래스를 변경하지
않고도 새로운 연산을 정의할 수 있게 한다.</pre>

</div>
<!-- EDIT27 SECTION "방문자(Visitor) 패턴" [5938-] -->