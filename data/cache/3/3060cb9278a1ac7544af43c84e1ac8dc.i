a:109:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"GoF 디자인 패턴";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:"이 패턴의 목차는 'GoF의 디자인 패턴'을 기준으로 함";}i:2;i:36;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:106;}i:6;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:106;}i:7;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"생성 패턴(Creational Patterns)";i:1;i:2;i:2;i:106;}i:2;i:106;}i:8;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:106;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:152;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:41:"추상 팩토리(Abstract Factory) 패턴";i:1;i:3;i:2;i:152;}i:2;i:152;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:152;}i:12;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:215:"구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 
서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴이다.";}i:2;i:201;}i:13;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:422;}i:14;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"빌더(Builder) 패턴";i:1;i:3;i:2;i:422;}i:2;i:422;}i:15;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:422;}i:16;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:163:"복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서
서로 다른 표현 결과를 만들 수 있게 하는 패턴이다.";}i:2;i:453;}i:17;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:622;}i:18;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:42:"팩토리 메서드(Factory Method) 패턴";i:1;i:3;i:2;i:622;}i:2;i:622;}i:19;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:622;}i:20;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:277:"객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 
서브 클래스 쪽에서 내리는 패턴이다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 
만드는 시점을 서브 클래스로 미룬다.";}i:2;i:673;}i:21;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:958;}i:22;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"원형(Prototype) 패턴";i:1;i:3;i:2;i:958;}i:2;i:958;}i:23;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:958;}i:24;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:174:"생성할 객체의 종류를 명세하는 데에 원형이 되는 예시물을 이용하고, 
그 원형을 복사함으로써 새로운 객체를 생성하는 패턴이다.";}i:2;i:991;}i:25;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1171;}i:26;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"단일체(Singleton) 패턴";i:1;i:3;i:2;i:1171;}i:2;i:1171;}i:27;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1171;}i:28;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:164:"어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 
전역적인 접촉적을 제공하는 패턴이다.";}i:2;i:1208;}i:29;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1382;}i:30;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"구조 패턴(Structural Patterns)";i:1;i:2;i:2;i:1382;}i:2;i:1382;}i:31;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1382;}i:32;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1428;}i:33;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"적응자(Adapter) 패턴";i:1;i:3;i:2;i:1428;}i:2;i:1428;}i:34;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1428;}i:35;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:236:"클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 
호환성이 없는 인터페이스 대문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 준다.";}i:2;i:1461;}i:36;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1703;}i:37;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"가교(Bridge) 패턴";i:1;i:3;i:2;i:1703;}i:2;i:1703;}i:38;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1703;}i:39;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:106:"구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.";}i:2;i:1732;}i:40;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1842;}i:41;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"복합체(Composite) 패턴";i:1;i:3;i:2;i:1842;}i:2;i:1842;}i:42;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1842;}i:43;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:184:"객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로,
사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 함";}i:2;i:1877;}i:44;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2067;}i:45;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"장식자(Decorator) 패턴";i:1;i:3;i:2;i:2067;}i:2;i:2067;}i:46;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2067;}i:47;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:197:"주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로,
기능 확장이 필요할 때 서브 클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다.";}i:2;i:2102;}i:48;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2305;}i:49;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"퍼사드(Facade) 패턴";i:1;i:3;i:2;i:2305;}i:2;i:2305;}i:50;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2305;}i:51;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:233:"서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로,
서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의함.";}i:2;i:2337;}i:52;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2576;}i:53;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"플라이급(Flyweight) 패턴";i:1;i:3;i:2;i:2576;}i:2;i:2576;}i:54;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2576;}i:55;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:119:"크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴이다.";}i:2;i:2614;}i:56;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2737;}i:57;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"프록시(Proxy) 패턴";i:1;i:3;i:2;i:2737;}i:2;i:2737;}i:58;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2737;}i:59;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:167:"어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate) 또는
자리채움자(placeholder)를 제공하는 패턴이다.";}i:2;i:2768;}i:60;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2943;}i:61;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"행동 패턴(Behavioral Patterns)";i:1;i:2;i:2;i:2943;}i:2;i:2943;}i:62;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2943;}i:63;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2990;}i:64;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:45:"책임 연쇄(Chain of Responsibility) 패턴";i:1;i:3;i:2;i:2990;}i:2;i:2990;}i:65;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2990;}i:66;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:365:"요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 
객체 사이의 결합을 피하는 패턴이다. 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 
처리할 수 있는 객체를 만날 때까지 객체 고리를 따라서 요청을 전달한다.";}i:2;i:3043;}i:67;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3416;}i:68;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"명령(Command) 패턴";i:1;i:3;i:2;i:3416;}i:2;i:3416;}i:69;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3416;}i:70;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:196:"요청을 객체-의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅,
그리고 연산의 취소를 지원하게 만드는 패턴이다.";}i:2;i:3446;}i:71;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3648;}i:72;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"해석자(Interpreter) 패턴";i:1;i:3;i:2;i:3648;}i:2;i:3648;}i:73;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3648;}i:74;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:224:"주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 아울러 그 표현 수단을 
사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴이다.";}i:2;i:3686;}i:75;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3916;}i:76;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"반복자(Iterator) 패턴";i:1;i:3;i:2;i:3916;}i:2;i:3916;}i:77;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3916;}i:78;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:157:"내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는
방법을 제공하는 패턴이다.";}i:2;i:3951;}i:79;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4114;}i:80;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"중재자(Mediator) 패턴";i:1;i:3;i:2;i:4114;}i:2;i:4114;}i:81;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4114;}i:82;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:337:"한 집합에 속해 있는 객체들의 상호작용을 캡슐화하는 객체를 정의한는 패턴이다. 객체들이
직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진시키며,
개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만든다.";}i:2;i:4149;}i:83;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4494;}i:84;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"메멘토(Memento) 패턴";i:1;i:3;i:2;i:4494;}i:2;i:4494;}i:85;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4494;}i:86;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:192:"캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가
그 상태로 되돌아올 수 있도록 하는 패턴이다.";}i:2;i:4528;}i:87;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4726;}i:88;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"감시자(Observer) 패턴";i:1;i:3;i:2;i:4726;}i:2;i:4726;}i:89;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4726;}i:90;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:246:"객체들 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체의 의존성을
가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴이다.";}i:2;i:4761;}i:91;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5013;}i:92;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"상태(State) 패턴";i:1;i:3;i:2;i:5013;}i:2;i:5013;}i:93;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5013;}i:94;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:192:"객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는
마치 자신의 클래스를 바꾸는 것처럼 보인다.";}i:2;i:5042;}i:95;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5240;}i:96;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"전략(Strategy) 패턴";i:1;i:3;i:2;i:5240;}i:2;i:5240;}i:97;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5240;}i:98;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:292:"동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화 하여, 이들을 상호 교환이 가능하도록
만드는 패턴이다. 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즙을 다양하게 변경할 수
있도록 한다.";}i:2;i:5272;}i:99;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5572;}i:100;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:43:"템플릿 메서드(Template Method) 패턴";i:1;i:3;i:2;i:5572;}i:2;i:5572;}i:101;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5572;}i:102;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:306:"객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로
미루는 패턴이다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서
재정의할 수 있게 한다.";}i:2;i:5624;}i:103;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5938;}i:104;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"방문자(Visitor) 패턴";i:1;i:3;i:2;i:5938;}i:2;i:5938;}i:105;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5938;}i:106;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:195:"객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 클래스를 변경하지
않고도 새로운 연산을 정의할 수 있게 한다.";}i:2;i:5973;}i:107;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5973;}i:108;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:5973;}}