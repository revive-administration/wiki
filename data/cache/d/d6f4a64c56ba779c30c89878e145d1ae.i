a:197:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"1장 소개";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:27;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:10:"1.1 변수";i:1;i:2;i:2;i:27;}i:2;i:27;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:27;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:53:"변수는 데이터를 표현하는 저장소이다. ";}i:2;i:49;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:102;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:104;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"1.2 데이터형";i:1;i:2;i:2;i:104;}i:2;i:104;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:104;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:104;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:698:"프로그래밍 언어에서 데이터형은 미리 정해진 특성을 가진 값들의 집합이다. 데이터형은 정수, 부동 소수점 숫자, 문자, 문자열 등이 있다. 어떤 문제를 풀기 위해 프로그램을 작성할 대 0과 1로만 답을 제시하기가 무척 어렵기 때문에 사용자를 돕기 위해 프로그래밍 언어와 컴파일러는 데이터형을 제공한다. 예를들어 정수는 2바이트, 실수는 4바이트를 차지한다. 이 말은 결국 메모리에서는 2바이트를 붙여서 정수라고 부른다는 것이다. 마찬가지로 4바이트를 붙여 실수라고 부른다. 데이터는 크게 나누어 두 가지 종류가 있다.";}i:2;i:132;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:831;}i:15;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:831;}i:16;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:831;}i:17;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:831;}i:18;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:831;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"시스템 정의 데이터형(원시 데이터형이라고도 불린다)";}i:2;i:836;}i:20;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:72:"시스템 정의 데이터형(원시 데이터형이라고도 불린다)";}i:2;i:836;}i:21;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:908;}i:22;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:908;}i:23;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:908;}i:24;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:908;}i:25;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:908;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"사용자 정의 데이터형";}i:2;i:913;}i:27;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:29:"사용자 정의 데이터형";}i:2;i:913;}i:28;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:942;}i:29;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:942;}i:30;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:942;}i:31;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:942;}i:32;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:944;}i:33;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:50:"시스템 정의 데이터형(원시 데이터형)";i:1;i:3;i:2;i:944;}i:2;i:944;}i:34;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:944;}i:35;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:944;}i:36;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:207:"시스템에 의해 정의된 데이터형을 원시 데이터형이라고 부른다. 많은 프로그래밍 언어에서 제공되는 원시 데이터형에는 int, float, char, double, bool 등이 있다. ";}i:2;i:1005;}i:37;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1213;}i:38;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1213;}i:39;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"사용자 정의 데이터형";i:1;i:3;i:2;i:1213;}i:2;i:1213;}i:40;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1213;}i:41;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1213;}i:42;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:"시스템 정의 데이터형으로 충분하지 않을 때 대부분의 프로그래밍 언어는 사용자가 직접 데이터형을 정의할 수 있게 해준다. 사용자 정의 데이터형의 좋은 예는 C/C++의 구조체와 Java의 클래스이다. ";}i:2;i:1253;}i:43;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1514;}i:44;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1516;}i:45;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"1.3 데이터 구조";i:1;i:2;i:2;i:1516;}i:2;i:1516;}i:46;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1516;}i:47;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1516;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:244:"앞의 논의에 의어서, 변수에 데이터를 담았다면 그 데이터를 이용해서 문제를 풀기 위한 기법이 필요해진다. 데이터 구조는 효율적으로 데이터를 저장하고 정리하는 특별한 방법이다. ";}i:2;i:1548;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1792;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1792;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"항목을 정리하는 방법에 따라 데이터 구조는 두 가지 종류로 나뉜다.";}i:2;i:1794;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1886;}i:53;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1886;}i:54;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1886;}i:55;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1886;}i:56;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:1886;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:142:"1) 선형 데이터 구조 : 항목들이 순차적 차례에 따라 접근되지만 순차적으로 저장되어야 하는 것은 아니다. ";}i:2;i:1891;}i:58;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:142:"1) 선형 데이터 구조 : 항목들이 순차적 차례에 따라 접근되지만 순차적으로 저장되어야 하는 것은 아니다. ";}i:2;i:1891;}i:59;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:7:"
    * ";}i:2;i:2033;}i:60;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:7:"
    * ";}i:2;i:2033;}i:61;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:7:"
    * ";}i:2;i:2033;}i:62;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:7:"
    * ";}i:2;i:2033;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"예) 연결 리스트, 스택, 큐";}i:2;i:2040;}i:64;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:34:"예) 연결 리스트, 스택, 큐";}i:2;i:2040;}i:65;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2074;}i:66;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2074;}i:67;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2074;}i:68;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2074;}i:69;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2074;}i:70;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2074;}i:71;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:2074;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"2) 비선형 데이터 구조 : 항목들이 비선형의 차례로 저장/접근된다";}i:2;i:2079;}i:73;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:87:"2) 비선형 데이터 구조 : 항목들이 비선형의 차례로 저장/접근된다";}i:2;i:2079;}i:74;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:7:"
    * ";}i:2;i:2166;}i:75;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:7:"
    * ";}i:2;i:2166;}i:76;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:7:"
    * ";}i:2;i:2166;}i:77;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:7:"
    * ";}i:2;i:2166;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"예) 트리, 그래프";}i:2;i:2173;}i:79;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:22:"예) 트리, 그래프";}i:2;i:2173;}i:80;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2195;}i:81;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2195;}i:82;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2195;}i:83;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2195;}i:84;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2195;}i:85;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:2195;}i:86;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2197;}i:87;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"1.4 추상 데이터형";i:1;i:2;i:2;i:2197;}i:2;i:2197;}i:88;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2197;}i:89;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2197;}i:90;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:181:"문제를 푸는 과정을 단순화시키기 위해 데이터 구조와 연산을 합쳐 놓을 것을 추상 데이터형이라고 하는데, ADT는 두 부분으로 구성된다.";}i:2;i:2234;}i:91;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2416;}i:92;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2416;}i:93;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2416;}i:94;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2416;}i:95;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2416;}i:96;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"1. 데이터의 선언";}i:2;i:2421;}i:97;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:22:"1. 데이터의 선언";}i:2;i:2421;}i:98;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2443;}i:99;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:2443;}i:100;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2443;}i:101;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:2443;}i:102;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:2443;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"2. 연산의 선언";}i:2;i:2448;}i:104;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:19:"2. 연산의 선언";}i:2;i:2448;}i:105;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2467;}i:106;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2467;}i:107;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:2467;}i:108;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:2467;}i:109;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2469;}i:110;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:36:"1.5 알고리즘이란 무엇인가?";i:1;i:2;i:2;i:2469;}i:2;i:2469;}i:111;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2469;}i:112;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2469;}i:113;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:2518;}i:114;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:" 알고리즘은 주어진 문제를 풀기 위한 단계별 지시사항들이다. ";}i:2;i:2520;}i:115;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:2604;}i:116;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2606;}i:117;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2608;}i:118;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:40:"1.6 왜 알고리즘을 분석하는가?";i:1;i:2;i:2;i:2608;}i:2;i:2608;}i:119;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2608;}i:120;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2608;}i:121;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"알고리즘 분석은 시간과 공간적으로 어느 것이 가장 효율적인지 알 수 있게 해준다.";}i:2;i:2661;}i:122;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2773;}i:123;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2773;}i:124;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:44:"1.8 수행 시간 분석이란 무엇인가?";i:1;i:2;i:2;i:2773;}i:2;i:2773;}i:125;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2773;}i:126;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2773;}i:127;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:313:"문제의 크기(입력의 크기)가 증가함에 따라 처리 시간이 얼마나 증가하는지를 분석하는 것이다. 입력 크기는 입력되는 항목의 개수인데 문제의 종류에 따라 입력의 종류도 달라진다. 일반적으로 다음과 같은 종류의 입력들을 볼 수 있다.";}i:2;i:2829;}i:128;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3143;}i:129;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3143;}i:130;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3143;}i:131;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3143;}i:132;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3143;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"배열의 크기";}i:2;i:3148;}i:134;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:16:"배열의 크기";}i:2;i:3148;}i:135;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3164;}i:136;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3164;}i:137;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3164;}i:138;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3164;}i:139;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:3164;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"다항식의 차수";}i:2;i:3169;}i:141;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:19:"다항식의 차수";}i:2;i:3169;}i:142;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3188;}i:143;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3188;}i:144;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3188;}i:145;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3188;}i:146;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:3188;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"행렬의 항목 개수";}i:2;i:3193;}i:148;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:23:"행렬의 항목 개수";}i:2;i:3193;}i:149;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3216;}i:150;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3216;}i:151;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3216;}i:152;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3216;}i:153;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:3216;}i:154;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:43:"이진으로 표현된 입력의 비트 수";}i:2;i:3221;}i:155;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:43:"이진으로 표현된 입력의 비트 수";}i:2;i:3221;}i:156;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3264;}i:157;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:3264;}i:158;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3264;}i:159;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:3264;}i:160;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:3264;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"그래프에서의 정점과 간선";}i:2;i:3269;}i:162;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:35:"그래프에서의 정점과 간선";}i:2;i:3269;}i:163;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:3304;}i:164;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:3304;}i:165;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:3304;}i:166;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:3304;}i:167;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3306;}i:168;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"1.13 점근적 표기법";i:1;i:2;i:2;i:3306;}i:2;i:3306;}i:169;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3306;}i:170;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3306;}i:171;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:300:"최선, 평균, 최악의 경우에 대한 수식이 있을 때, 이 세 개의 경우 모두에 대해 상한과 하한을 찾아야 한다. 이러한 상한과 하한을 표현하기 위해 필요한 문법을 알아보자. 주어진 알고리즘이 함수 f(n)의 형태로 표현된다고 하자.";}i:2;i:3343;}i:172;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3643;}i:173;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3645;}i:174;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"1.14 빅-오 표기법";i:1;i:2;i:2;i:3645;}i:2;i:3645;}i:175;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3645;}i:176;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3645;}i:177;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"이 표기법은 주어진 함수에 대해 엄밀한(tight) 상한을 찾게 해준다. ";}i:2;i:3680;}i:178;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3770;}i:179;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:120:"O(g(n)) = { f(n) : n >= n0 인 모든 n에 대해 0<=f(n)<=cg(n)을 만족하는 양의 상수 c와 n0이 존재한다 }";}i:2;i:3770;}i:180;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3770;}i:181;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:185:"g(n)은 f(n)의 엄밀한 점근적 상한이다. 이 때 우리의 목적은 주어진 알고리즘의 증가율 f(n)과 크거나 같은 최소의 증가율 g(n)을 찾는 것이다. ";}i:2;i:3895;}i:182;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4080;}i:183;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4082;}i:184;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"1.15 오메가 표기법";i:1;i:2;i:2;i:4082;}i:2;i:4082;}i:185;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:4082;}i:186;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4082;}i:187;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:"이 표기법은 주어진 알고리즘에 대해 엄밀한 하한을 찾게 해주며 f(n) = 오메가(g(n))으로 표현된다.";}i:2;i:4119;}i:188;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4248;}i:189;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4251;}i:190;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"1.16 세타 표기법";i:1;i:2;i:2;i:4251;}i:2;i:4251;}i:191;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:4251;}i:192;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4251;}i:193;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:196:"이 표기법은 주어진 함수 (알고리즘)의 상한과 하한이 같은지 아닌지를 결정한다. 알고리즘의 평균 수행 시간은 항상 하한과 상한 사이에 존재한다.";}i:2;i:4285;}i:194;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4481;}i:195;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4481;}i:196;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4481;}}