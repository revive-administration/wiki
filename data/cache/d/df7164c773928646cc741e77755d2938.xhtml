
<h1 class="sectionedit1" id="chapter_8">Chapter 8</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Chapter 8" [1-24] -->
<h2 class="sectionedit2" id="하드웨어와_제어구조">8.1 하드웨어와 제어구조</h2>
<div class="level2">

<p>
단순페이징과 단순 세그먼테이션을 고정분할 혹은 가변분할과 비교해 보면, 메모리 관리에 있어 근본 타개책을 모색하기 위한 기초를 발견하게 된다. 페이징과 세그먼테이션이 갖는 다음의 두가지 특성이 그 타개책의 실마리가 된다.
</p>
<ul>
<li class="level1"><div class="li"> 1. 프로세스의 모든 메모리 참조는 논리주소이며, 이 주소는 프로세스 수행 시간에 동적으로 물리주소로 변환된다. 이는 한 프로세스가 그 수행 과정에서 스와핑을 통해 다시 주기억장치에 적재될 때, 그 이전과 다른 위치에 적재될 수 있음을 의미한다.</div>
</li>
<li class="level1"><div class="li"> 2. 한 프로세스의 주소공간은 여러 블록(페이지 혹은 세그먼트)으로 분할될 수 있고, 프로세스 수행 중 이 블록들은 주기억장치의 연속된 영역에 위치할 필요가 없다. 이는 프로세스가 수행될 때 페이지(혹은 세그먼트) 테이블을 활용해 동적으로 주소를 변환함으로써 가능케 된다.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> &lt;가상 메모리 관련 핵심 용어&gt;  </div>
<ul>
<li class="level2"><div class="li"> 가상메모리 : 보조기억장치를 주기억장치처럼 주소지정 가능하게 만든 저장공간 할당체제. 프로그램이 메모리를 참조할 때 사용하는 주소는 메모리 시스템이 물리 메모리의 특정 위치를 식별할 때 사용하는 주소와 구별된다. 프로그램이 생성한 주소는 그에 대응된 물리주소로 자동 변환된다. 가상메모리의 크기는 주기억장치의 크기가 아니라 컴퓨터 시스템의 주소지정체제와 보조기억장치의 가용크기에 의해 제한된다.</div>
</li>
<li class="level2"><div class="li"> 가상주소 : 주기억장치처럼 참조될 수 있도록 가상메모리의 특정위치에 배정된 주소</div>
</li>
<li class="level2"><div class="li"> 가상주소공간 : 특정 프로세스에게 할당된 가상 주소의 영역</div>
</li>
<li class="level2"><div class="li"> 주소공간 : 특정 프로세스가 접근할 수 있는 메모리 주소의 영역</div>
</li>
<li class="level2"><div class="li"> 실주소 : 주기억장치 상의 특정 저장위치의 주소</div>
</li>
</ul>
</li>
</ul>

<p>
새로운 프로세스가 메모리에 반입되어야 할 상황을 가정해보자. 운영체제는 초기에 수행될 코드와 참조될 데이터가 포함되도록 단지 하나 혹은 몇 개의 블록만 반입한다. 프로세스의 코드나 데이터 중 임의 시점에 주기억장치에 적재되어 있는 부분을 해당 프로세스의 적재집합(resident set)이라 한다. 프로세스가 적재집합에 포함된 주소를 참조하며 수행되는 동안은 그 수행이 순조롭다. 처리기는 세그먼트테이블이나 페이지테이블을 이용하여 프로세스의 참조 주소가 적재집합에 포함되어 있는지를 판단할 수 있다. 만약 주기억장치에 적재되지 않은 논리주소가 참조될 경우, 처리기는 메모리 접근 오류(memory access fault)를 의미하는 인터럽트를 발생시킨다. 
</p>

<p>
운영체제는 인터럽트 당한 프로세스를 블록 상태에 두고 제어를 넘겨받는다. 나중에 그 프로세스의 수행을 재개하려면, 해당 논리주소를 포함한 프로세스의 블록을 주기억장치로 적재해야 한다. 이를 위해 운영체제는 디스크 입출력 요청을 하게 되며, 그 후 다른 프로세스에게 CPU를 넘겨 디스크 입출력이 진행되는 동안 수행될 수 있게 한다. 요청된 디스크 입출력이 끝나면 입출력 인터럽트가 발생하게 되고, 이를 통해 제어를 돌려받은 운영체제는 이전의 메모리 접근오류를 발생시켜 블록되었던 프로세스를 준비상태로 전환시킨다. 
</p>

<p>
프로세스가 일부 블록만을 적재한 채 수행되고, 적재되어 있지 않은 블록들로 인해 반복적으로 인터럽트 당할 것이 명백하다는 점에서, 이 기법의 효율성에 대한 의구심이 생길 수 있다. 이 기법에 함축된 두가지를 생각해보자.
</p>
<ul>
<li class="level1"><div class="li"> 1. 보다 많은 프로세스를 주기억장치에 유지할 수 있다. : 각 프로세스에 대해 일부 블록들만 적재하기 때문에 보다 많은 프로세스를 적재할 수 있다. 이로 인해 임의 시점에 하나 이상의 프로세스가 준비 상태에 있을 가능성이 커지므로, 처리기의 활용도가 높아진다.</div>
</li>
<li class="level1"><div class="li"> 2. 주기억장치보다 큰 프로세스를 수행할 수 있다. : 프로그래밍에 있어 가장 근본적 제약점 중 하나가 제거된다. 이 기법을 적용하지 않을 경우, 프로그래머는 얼마나 많은 메모리 공간을 사용할 수 있는지 정확히 인식해야 한다. </div>
</li>
</ul>

<p>
프로세스는 단지 주기억장치에서 수행할 수 있기 때문에, 주기억장치는 실기억장치라 불린다. 그러나 이제 프로그래머나 사용자는 디스크 상에 할당된 훨씬 큰 잠재적 메모리를 갖게 되었으며, 이를 가상 메모리라고 부른다. 
</p>

</div>
<!-- EDIT2 SECTION "8.1 하드웨어와 제어구조" [25-4931] -->
<h3 class="sectionedit3" id="지역성과_가상메모리">지역성과 가상메모리</h3>
<div class="level3">

<p>
안정 상태에서는 처리기나 운영체제가 가능한 한 많은 프로세스를 직접 접근할 수 있게 하기 위해, 주기억장치 전체가 프로세스 블록들로 채워져 있게 된다. 따라서 운영체제가 한 블록을 반입하려면 다른 블록 하나를 반출해야 한다. 만약 특정 블록이 사용되기 직전에 반출되었다면 그 불록은 거의 곧바로 반입된다. 이게 과도하면 쓰레싱(thrashing)에 이르게 되어, 시스템은 명령어 수행이 아닌 블록 교체에 대부분의 시간을 소비하게 된다.
</p>

</div>
<!-- EDIT3 SECTION "지역성과 가상메모리" [4932-5556] -->
<h3 class="sectionedit4" id="페이징">페이징</h3>
<div class="level3">

</div>

<h4 id="페이지_테이블_구조">페이지 테이블 구조</h4>
<div class="level4">

<p>
메모리에서 한 워드를 읽을 때마다 페이지 번호와 오프셋으로 구성된 가상 주소(혹은 논리주소)가 물리주소(프레임 번호와 오프셋으로 구성)로 변환된다. 페이지테이블은 프로세스의 크기에 따라 그 크기가 달라지므로 레지스터에 넣을 수 없으며, 그런 이유로 메모리에 저장된다.
</p>

</div>

<h4 id="역페이지테이블">역페이지테이블</h4>
<div class="level4">

<p>
지금까지 논의된 페이지테이블 타입의 단점은 그 크기가 가상주소공간의 크기에 비례한다는 점이다. 이런 관점에서 1-단계 혹은 다단계 페이지테이블 사용에 대한 대안적 접근은 역페이지테이블(inverted page table)을 사용하는 것이다.
</p>

<p>
이 접근 방법의 경우, 가상 주소 중 페이지번호 부분은 간단한 해시 함수(hash function)를 통해 특정 해시 값(hash value)으로 사상된다. 해시값은 역페이지 테이블에 대한 인덱스로 쓰이고, 역페이지테이블은 페이지테이블 항목들로 구성된다. 페이지테이블 항목이 가상메모리의 페이지 당 하나씩이 아니라 실기억장치의 페이지프레임당 하나씩 설정되기 때문에, 프로세스의 수나 지원되는 가상 페이지 수와 상관없이 주기억장치의 일정 부분만이 테이블 저장에 쓰인다. 하나 이상의 가상주소들이 동일한 해시테이블 항목으로 사상될 수 있기 때문에, 오버플로우를 관리하기 위한 연결(chaining) 기법이 사용되는데, 해싱 기법은 전형저긍로 한두 개의 항목 간에 짧은 체인을 만든다. 이러한 페이지테이블 구조를 명명할때 역의 의미를 포함시킨 것은 가상메모리의 페이지 번호가 아니라 프레임 번호로 페이지테이블 항목을 인덱싱하기 때문이다.
</p>
<ul>
<li class="level1"><div class="li"> 페이지 번호 : 가상주소의 페이지 번호를 나타낸다.</div>
</li>
<li class="level1"><div class="li"> 프로세스 식별자 : 해당 페이지를 소유한 프로세스의 식별자로, 페이지 번호와 결합될 경우 해당 프로세스의 가상주소공간에 포함된 특정 페이지를 유일하게 식별한다.</div>
</li>
<li class="level1"><div class="li"> 제어비트 : 유효(valid), 참조(reference), 변경(modify), 보호(protection), 잠금(locking)등의 정보를 나타내는 플래그 필드들이 포함된다.</div>
</li>
<li class="level1"><div class="li"> 체인포인터 : 연결된 항목이 없을 경우 null(별개의 비트로 표현될 수 있음), 그렇지 않을 경우 체인 상의 다음 항목을 가리키는 인덱스값(0과 2^m - 1 사이의 수)이 저장된다.</div>
</li>
</ul>

</div>

<h4 id="tlb_translation_lookaside_buffer">TLB(Translation Lookaside Buffer)</h4>
<div class="level4">

<p>
원칙적으로 모든 가상메모리 참조는 두 번의 물리메모리 참조를 수반하는데, 한 번은 해당 페이지테이블 항목을 참조하기 위함이고, 다른 한 번은 요구된 데이터를 접근하기 위함이다. 이런 가상메모리 방식은 두 배의 메모리 접근 시간을 갖게 한다. 이 문제를 해결하기 위해 대부분의 가상메모리 방식은 페이지테이블 항목들에 대한 특수 고속 캐시를 사용하는데 이를 Translation Lookaside Buffer라 부른다. 메모리 캐시가 가장 최근에 참조된 데이터나 명령어를 유지하는 것처럼, TLB는 가장 최근에 참조된 페이지테이블 항목들을 유지한다. 가상주소가 주어지면, 처음에 TLB를 살펴보아 그곳에 있으면 바로 프레임 번호가 추출되어 실주소가 구성된다. 만약 해당 페이지테이블 항목이 없으면 페이지 번호로 페이지테이블을 인덱싱하여 페이지테이블 항목을 참조한다. 페이지 테이블 항목의 존재비트가 1일 경우 해당 페이지가 주기억장치에 존재하므로, 페이지테이블 항목에 저장된 프레임 번호를 이용하여 실주소를 구성한다. TLB는 해당 페이지테이블 항목을 포함하도록 갱신된다. 페이지테이블 항목의 존재비트가 0일 경우, 해당 페이지가 주기억장치에 없을을 의미하므로 페이지폴트(page fault)라 불리는 메모리 접근 오류가 발생된다. 이 시점에서 하드웨어의 역할은 끝나고 운영체제가 호출되며, 운영체제는 필요한 페이지를 적재하고 페이지 테이블을 갱신한다.
</p>

<p>
TLB의 실제 구성과 관련된 추가적인 세부 사항들이 있다. TLB가 단지 페이지테이블의 일부 항목들만 포함하고 있기 때문에, 페이지 번호를 TLB의 인덱스로 사용할 수 없다. 대신에 TLB의 항목들은 페이지테이블 항목의 내용 뿐만 아니라 페이지 번호를 포함해야 한다. 그리고 처리기에는 특정 페이지 번호와 일치하는 TLB 항목이 있는지 결정하기 위해 다수의 TLB 항목들을 동시에 조사하는 하드웨어가 장착도니다. 이런 기법을 연관사상이라 한다.
</p>

<p>
최종적으로 가상메모리 기법은 주기억장치 캐시 시스템과 상호작용해야 한다. 가상주소는 일반적으로 페이지번호와 오프셋으로 구성된다. 태그와 나머지 부분으로 구성된 실주소가 생성되면 해당 워드를 포함한 블록이 캐시 상에 존재하는지 조사한다. 그렇지 않을 경우 해당 워드는 주기억장치로부터 읽히게 된다. 
</p>

</div>

<h4 id="페이지_크기">페이지 크기</h4>
<div class="level4">

<p>
큰 프로그램을 개발할 때 사용되는 현대의 프로그래밍 기술들은 프로세스 내에서의 참조 지역성을 감소시키고 있다. 예를 들면 다음과 같다
</p>
<ul>
<li class="level1"><div class="li"> 객체 지향 기술은 다수의 작은 프로그램과 데이터 모듈을 사용하도록 조장함으로써, 상대적으로 잛은 시간 내에 이루어지는 참조들이 상대적으로 많은 객체들을 대상으로 분산되게 한다.</div>
</li>
<li class="level1"><div class="li"> 멀티 쓰레도 응용은 명령어 스트림이나 분산된 메모리 참조에 대해 급작스런 변화를 초래할 수 있다.</div>
</li>
</ul>

<p>
TLB 크기가 고정되어 있다고 할 때 프로세스의 메모리 크기가 커지면, 지역성을 줄어들고 TLB에 대한 적중률 또한 떨어진다. 이러한 환경의 경우 TLB가 성능의 병목지점이 된다. TLB의 성능 개선 방법 중 하나는 보다 많은 항목을 가진 TLB를 사용하는 것이다. 그러나 TLB의 크기는 주기억장치 캐시나 명령어 수행 사이클 당 메모리 참조 회수 등 하드웨어 설계의 다른 측면들과 관련되어 있다. 요점은 주기억장치 용량이 급속히 커지듯 TLB 크기가 쉽게 커지지 못하단는 것이다. 다수의 페이지 크기가 지원될 경우 TLB를 효과적으로 사용하는데 필요한 유연성이 생긴다. 
</p>

</div>
<!-- EDIT4 SECTION "페이징" [5557-12211] -->
<h3 class="sectionedit5" id="세그먼테이션">세그먼테이션</h3>
<div class="level3">

</div>

<h4 id="가상메모리의_유익">가상메모리의 유익</h4>
<div class="level4">

<p>
세그먼테이션은 프로그래머가 메모리를 다수의 주소공간들(혹은 세그먼트들)의 조합으로 볼 수 있게 해 준다. 세그먼트들의 크기는 서로 다르게 동적으로 설정될 수 있으며, 메모리 참조는 (세그먼트 번호, 오프셋)의 주소 형식으로 이루어진다. 이러한 구성은 세그먼트로 분할되지 않은 주소공간에 비할 때, 프로그래머에게 다음과 같은 몇 가지 유익을 준다.
</p>

<p>
1. 점진적으로 커져가는 자료구조의 처리를 단순화시킨다. 만약 프로그래머가 특정 자료구조가 얼마나 커질 지 미리 알지 못한다면, 세그먼트 크기의 동적 설정이 허용되지 않는 한 그 크기를 추정해야 한다. 세그먼트 기반 가상메모리의 경우 자료구조에 특정 세그먼트를 배정하여, 필요에 따라 운영체제가 그 세그먼트를 확장,축소하게 할 수 있다. 확장할 세그먼트와 인접한 영역에 충분한 메모리 공간이 없을 때, 보다 큰 가용 공간으로 이동시켜, 해당 세그먼트를 확장할 수 있다. 그런 가용공간이 없다면 일단 해당 세그먼트를 스왑-아웃시켜 두었다가 나중에 확장된 형태의 세그먼트를 스왑인 시킬 수 있다.
</p>

<p>
2. 프로그램 전체에 대한 재연결이나 재적재없이, 세그먼트 각각을 독립적으로 변경하거나 재컴파일 할 수 있다. 이는 다수의 세그먼트를 사용함으로써 가능해진 것이다.
</p>

<p>
3. 프로세스들이 세그먼트를 공유할 수 있다. 프로그래머는 유틸리티 코드나 유용한 데이터 테이블 등을 한 세그먼트로 설정하여 다른 프로세스들이 참조하게 할 수 있다.
</p>

<p>
4. 세그먼트를 보호할 수 있다.
</p>

</div>

<h4 id="구성">구성</h4>
<div class="level4">

<p>
세그먼트 테이블 항목의 또 다른 제어 비트로 변경 비트가 있는데 이는 해당 세그먼트가 적재된 이후 그 내용이 변경되었는지를 나타낸다. 세그먼트 교체 시 변겨오딘 세그먼트만 구별하여 디스크에 기록할 수 있게 해준다.
</p>

</div>
<!-- EDIT5 SECTION "세그먼테이션" [12212-14371] -->
<h3 class="sectionedit6" id="페이징과_세그먼테이션의_결합">페이징과 세그먼테이션의 결합</h3>
<div class="level3">

</div>
<!-- EDIT6 SECTION "페이징과 세그먼테이션의 결합" [14372-14423] -->
<h2 class="sectionedit7" id="운영체제_소프트웨어">8.2 운영체제 소프트웨어</h2>
<div class="level2">

<p>
운영체제 메모리관리 부분의 설계는 다음 세 가지 기본 선택 영역에 의존한다
</p>
<ul>
<li class="level1"><div class="li"> 가상메모리 기술을 사용할지 여부</div>
</li>
<li class="level1"><div class="li"> 페이징, 세그먼테이션, 혹은 세그먼테이션/페이징 결합의 사용</div>
</li>
<li class="level1"><div class="li"> 메모리 관리와 관련된 알고리즘들</div>
</li>
</ul>

</div>
<!-- EDIT7 SECTION "8.2 운영체제 소프트웨어" [14424-14761] -->
<h3 class="sectionedit8" id="교체정책">교체정책</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> 활동 중인 각 프로세스에 얼마나 많은 프레임을 할당할 것인가</div>
</li>
<li class="level1"><div class="li"> 교체 페이지로 고려될 대상을, 페이지폴트를 발생시켜 페이지를 반입하게 한 프로세스의 페이지들로 한정할 것인가, 아니면 주기억장치 상의 모든 프레임으로 확대할 것인가</div>
</li>
<li class="level1"><div class="li"> 고려 대상 페이지들 중에 어떤 페이지를 교체 대상으로 선택할 것인가</div>
</li>
</ul>

<p>
처음 두 개념은 &#039;적재집합 관리&#039;라 명명되어 다음 소절에서 다루고, 세 번째 개념은 교체정책이라는 용어를 사용하여 본 절에서 다룬다.
</p>

</div>

<h4 id="프레임_잠금_frame_locking">프레임 잠금(Frame Locking)</h4>
<div class="level4">

<p>
교체 알고리즘들을 살펴보기 이전에 그 제약조건 중 하나인 프레임 잠금 개념이다. 해당 프레임에 적재된 페이지가 교체되지 않도록 표시해 두는 것이다. 입출력 버퍼, 시간임계영역 등도 주기억장치의 프레임들에 잠가 둘 수 있다. 
</p>

</div>

<h4 id="기본_알고리즘">기본 알고리즘</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> 최적</div>
</li>
<li class="level1"><div class="li"> LRU(Least Recently Used)</div>
</li>
<li class="level1"><div class="li"> FIFO(First-In-First-Out)</div>
</li>
<li class="level1"><div class="li"> 클록(Clock)</div>
</li>
</ul>

<p>
최적 정책은 미래에 참조될 때까지의 시간이 가장 긴 페이지를 교체 대상으로 선택한다. 실제 구현 가능한 알고리즘들을 평가하는 기준이 된다. LRU 정책은 가장 오랜 동안 참조되지 않은 주기억장치상의 페이지를 교체한다. FIFO 정책은 프로세스에 할당된 페이지프레임들을 순환버퍼처럼 다루어, 라운드로빈 스타일로 프레임 상의 페이지들을 제거한다. 가장 오래 전에 반입된 페이지는 이제 사용되지 않을 것이라는 논리인데, 이는 종종 좋지 않은 결과를 초래하는데, 많은 경우에 프로그램 수행 과정 내내 집중적으로 이용되는 코드나 데이터들이 존재하기 때문이다. 오버헤드가 적은 반면 LRU의 성능에 근접한 알고리즘으로 클록 정책(clock policy)와 같은 변형을 들 수 있다.
</p>

<p>
클록 정책의 가장 단순한 형태는 각 프레임에 대해 사용비트(use bit)라 불리는 한 비트를 연계시킨다. 페이지 폴트로 인해 어떤 페이지가 메모리 프레임에 처음 반입될 때, 그 프레임의 사용비트는 1로 설정된다. 하나의 포인터가 있어 첫 교체 후보를 가리킨다. 특정 페이지가 교체될 경우, 포인터는 그 다음 페이지를 가리키게 된다. 교체할 페이지를 찾을 때 운영체제는 포인터가 가리키는 프레임부터 시작하여 순서대로 점검하며 사용비트가 0인 프레임을 찾는데 1인 프레임을 만나면 그 값을 0으로 바꾼 후 다음 프레임으로 진행한다.
</p>

<p>
요약하면, 페이지 교체 알고리즘은 반입된 후 변경되지 않고 최근에 참조되지 않은 페이지를 찾아 버퍼 상의 모든 페이지들을 훑어가며 순환한다. 
</p>

</div>

<h4 id="페이지_버퍼링">페이지 버퍼링</h4>
<div class="level4">

<p>
LRU와 클록정책은 복잡성과 오버헤드를 갖고 있다. 페이지 버퍼링은 페이지 성능을 향상시키는 동시에 단순한 페이지 교체정책을 허용하는 흥미있는 전략으로 VAX VMS 접근 방법이 그 대표적 사례다. 단순 FIFO정책을 적용해 교체 대상을 선정하지만, 선정된 페이지를 바로 교체하지 않고 그 페이지가 변경되지 않은 페이지인 경우 가용 페이지 리스트에, 변경된 페이지인 경우 변경 페이지 리스트에 연결시켜 관리한다. 페이지가 주기억장치 상에서 물리적으로 이동되는 것이 아니라, 해당 페이지에 대한 사상정보가 페이지테이블 항목으로부터 제거되고 관련 정보가 가용페이지 리스트나 변경페이지 리스트에 연결된다는 것이다.
</p>

<p>
이 전략의 주요 측면은 교체되는 페이지가 메모리에 남아있다는 것이다. 따라서 어떤 프로세스가 그런 페이지를 참조할 경우, 적은 비용으로 그 페이지를 해당 프로세스의 적재집합에 복귀시킬 수 있다. 사실상, 가용/변경페이지 리스트는 페이지들의 캐시 역할을 한다.
</p>

</div>

<h4 id="교체정책과_캐시_크기">교체정책과 캐시 크기</h4>
<div class="level4">

<p>
페이지버퍼링과 유사한 전략을 사용하는 시스템에서 페이지 교체정책을 페이지 버퍼 상에서 배치정책으로 보완함으로써 캐시 성능을 개선할 수 있다.
</p>

</div>
<!-- EDIT8 SECTION "교체정책" [14762-19117] -->
<h3 class="sectionedit9" id="적재집합_관리">적재집합 관리</h3>
<div class="level3">

</div>

<h4 id="적재집합의_크기">적재집합의 크기</h4>
<div class="level4">

<p>
페이징 기반 가상 메모리의 경우, 수행을 위해 프로세스의 페이지 모두를 주기억장치에 적재하는 것은 불필요하며 가능치 않을 수도 있다. 따라서 운영체제는 얼마나 많은 페이지를 반입할지를 결정해야 한다. 몇가지 인자가 다음과 같이 작용한다.
</p>
<ul>
<li class="level1"><div class="li"> 한 프로세스에게 할당된 메모리의 양이 적을수록, 임의 시점에 주기억장치에 존재 가능한 프로세스가 많아진다. 이는 특정 시점에 적어도 하나 이상의 준비 상태 프로세스가 존재할 가능성을 높여, 운영체제가 스와핑으로 인한 시간적 손실을 절감할 수 있게 해 준다.</div>
</li>
<li class="level1"><div class="li"> 주기억장치 상에 적재된 한 프로세스의 페이지 수가 상대적으로 작으면, 지역성의 원리에도 불구하고 페이지폴트 발생률이 오히려 더 높아질 것이다.</div>
</li>
<li class="level1"><div class="li"> 적재된 페이지 수가 어느 정도 이상이면, 해당 프로세스에 대해 주기억장치를 추가할당하더라도 지역성의 원리에 의해 그 프로세스의 페이지폴트 발생률에 큰 영향이 없을 것이다.</div>
</li>
</ul>

<p>
고정할당(fixed-allocation) 정책은 각 프로세스에게 고정 개수의 페이지프레임을 주고 수행시킨다. 프레임 수는 초기적재시점(프로세스 생성시점)에 결정되는데, 프로세스이 타입이나 프로그래머 혹은 시스템 관리자의 지침 등이 결정의 근거가 된다. 고정할당 정책에서는 프로세스 수행 중에 페이지폴트가 발생할 경우 그 프로세스에 할당한 페이지 중 하나가 새로운 페이지로 교체된다.
</p>

<p>
또 다른 하나인 가변할당(variable-allocation) 정책은 프로세스 생존 기간 동안 각 프로세스에 할당된 페이지프레임 수의 변경을 허용한다. 지속적으로 높은 수준의 페이지폴트 발생률을 보이고 있는 프로세스에게 페이지프레임을 추가 할당하여 페이지폴트 발생률을 줄이고, 현저히 낮은 페이지폴트 발생률을 보이는 프로세스로부터 페이지 폴트 발생률이 그리 크게 증가되지 않을 정도로 할당량을 줄인다. 
</p>

</div>

<h4 id="교체_범위">교체 범위</h4>
<div class="level4">

<p>
교체 전략의 범위(scope)는 전역과 지역으로 분류될 수 있다. 두 타입의 정책 모두 가용 페이지프레임이 없을 때 발생된 페이지폴트에 의해 활성화된다. 지역교체 정책(local replacement policy)은 페이지폴트를 발생시킨 프로세스의 적재 페이지들 중에서 교체 대상 페이지를 선택한다. 전역교체 정책(global replacement policy)은 어떤 프로세스가 소유한 것인지에 상관없이 주기억장치 상의 잠기지 않은 모든 페이지를 교체 후보로 고려한다. 지역 정책이 분석하기 쉽겠지만 전역 정책에 비해 보다 효과적이라는 확실한 증거는 없으며, 오히려 전역 정책이 구현의 용이함이나 최소 오버헤드 대문에 매력적이다.
</p>

<p>
교체범위와 적재집합의 크게 간에는 관련성이 있다. 고정된 적재집합은 지역교체 정책을 함축하는데, 이는 적재집합의 크기를 고정하려면 주기억장치에서 제거되는 페이지를 동일 프로세스의 또 다른 페이지로 교체해야 하기 때문이다. 이에 반해 가변할당 정책은 명확히 전역 정책을 적용하며, 한 프로세스의 페이지를 다른 프로세스의 페이지로 교체할 때 후자의 할당량은 한 페이지 늘어나고 전자의 할당량은 한 페이지 줄어든다.
</p>
<div class="table sectionedit10"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0"> </th><th class="col1">지역 교체</th><th class="col2">전역 교체</th>
	</tr>
	</thead>
	<tr class="row1">
		<td class="col0">고정할당 </td><td class="col1"> 프로세스에게 할당된 프레임 수 고정. <br/>
해당 프로세스에게 할당된 프레임 중에서 교체될 페이지 선택 </td><td class="col2"> 불가</td>
	</tr>
	<tr class="row2">
		<td class="col0"> 가변 할당 </td><td class="col1"> 프로세스에게 할당된 프레임 수는 프로세스의 작업집합을 유지하기 위해 수시로 변경 가능 <br/>
해당 프로세스에게 할당된 프레임 중에서 교체될 페이지 선택 </td><td class="col2"> 주기억장치의 모든 프레임 중에 교체될 페이지 선택. 이로 인해 프로세스의 적재집합 크기가 변경됨</td>
	</tr>
</table></div>
<!-- EDIT10 TABLE [22756-23313] -->
</div>

<h4 id="가변할당_전역_범위">가변할당, 전역 범위</h4>
<div class="level4">

<p>
이는 많은 운영체제들에 의해 채택된 결합으로 가장 구현하기 쉽다. 임의 시점에 주기억장치에 다수의 프로세스들이 존재하며, 각 프로세스에게 어느 정도의 페이지 프레임들이 할당되어 있다. 페이지 폴트를 발생시키고 있는 프로세스는 그 크기가 점진적으로 증가되고, 전체적으로 시스템의 페이지폴트를 줄이려 한다.
</p>

<p>
이 접근방법의 어려움은 교체 대상 선정이다. 페이지버퍼링을 이용하면 페이지가 덮여 쓰이기 전에 참조되면 다시 회수될 수 있기 때문에, 어떤 페이지가 교체 대상으로 선택되는지가 덜 중요하다.
</p>

</div>

<h4 id="가변할당_지역범위">가변할당, 지역범위</h4>
<div class="level4">

<p>
이 전략은 전역범위 전략의 문제점을 극복하기 위해 다음 방식을 사용한다.
</p>
<ul>
<li class="level1"><div class="li"> 1. 새로운 프로세스가 주기억장치로 적재될 때, 응용의 타입이나 프로그램의 요구, 혹은 또 다른 척도들에 근거하여 어느 정도의 페이지프레임들을 적재집합으로 할당한다.</div>
</li>
<li class="level1"><div class="li"> 2. 페이지폴트가 발생할 경우, 그것을 발생시킨 프로세스의 적재집합 중에서 교체할 페이지를 선택한다.</div>
</li>
<li class="level1"><div class="li"> 3. 수시로 프로세스에 대한 할당량을 재평가하고 전체적 성능 개선이라는 측면에서 할당량을 증감시킨다.</div>
</li>
</ul>

<p>
가변 할당/지역범위 전략의 주요소는 적재집합의 크기와 그 변경시점을 결정하는데 사용되는 규칙이다. 그중 하나가 작업집합 전략(working setstrategy)이다. 특정 프로세스에 대해 가상시점 t와 파라미터 d로 정의된 작업집합 W(t,d)는 그 프로세스가 시점 t 직전에 가상시간 d동안 참조한 페이지들의 집합이다. 작업집합 개념은 적재집합의 크기를 결정하는 전략의 지침이 될 수 있다.
</p>
<ul>
<li class="level1"><div class="li"> 1. 각 프로세스의 작업집합을 모니터링한다.</div>
</li>
<li class="level1"><div class="li"> 2. 주기적으로 프로세스의 적재집합 중 작업집합에 있지 않은 페이지들을 제거한다. 이는 기본적으로 LRU 정책이다.</div>
</li>
<li class="level1"><div class="li"> 3. 프로세스는 주기억장치에 그 작업집합에 있을대만 수행된다.</div>
</li>
</ul>

<p>
작업집합을 직접 모니터링하지 않고, 페이지폴트 발생률을 모니터링 함으로써 유사한 결과를 얻을 수 있다. 만약 한 프로세스의 페이지폴트 발생률이 최소 임계치보다 낮으면, 해당 프로세스에게 해를 끼치지 않고 적재집합을 줄일 수 있어 시스템 전체적 이득을 얻을 수 있다. 한 프로세스의 폴트 발생률이 최대 임계치보다 높으면 적재크기를 증가시켜 유익을 준다.
</p>

<p>
이 전략을 따르는 알고리즘 중 하나가 PFF(Page Fault Frequency)이다. PFF는 새로운 지역성으로 전이해 가는 과도 기간 동안 효과적으로 동작하지 않는다는 단점이 있다. 지역성간 전이현상을 적은 오버헤드로 다루어보려는 접근 방법 중 하나가 VSWS(Variable-interval Sampled Working Set) 정책이다. VSWS정책은 경과된 가상시간에 근거한 생플링들을 통해 프로세스의 작업집합을 평가한다.
</p>

</div>
<!-- EDIT9 SECTION "적재집합 관리" [19118-26490] -->
<h3 class="sectionedit11" id="클리닝정책_cleaning_policy">클리닝정책(Cleaning Policy)</h3>
<div class="level3">

<p>
요구클리닝(demand cleaning)에서 각 페이지는 그것이 교체 대상으로 선택되었을 때만 보조기억장치에 기록된다. 선 클리닝(precleaning)은 해당 페이지프레임이 요구되기 전에 변경된 페이지들을 기록함으로써 그들이 일괄 기록될 수 있게 한다. 
</p>

<p>
보다 나은 접근방법은 페이지버퍼링을 접목하여 다음과 같은 정책을 적용하는 것이다. 교체 가능한 페이지들만 기록하고, 클리닝과 교체를 분리시킨다. 페이지버퍼링에 있어 교체된 페이지들을 변경 리스트와 비변경 리스트로 옮긴다. 이와 같이 페이지들을 관리함으로써 비변경리스트 상의 페이지는, 차몾될 경우 재활용되고, 해당 프레임이 다른 페이지에 할당될 경우 기록 작업 없이 바로 페이지 반입에 이용될 수 있게 된다.
</p>

</div>
<!-- EDIT11 SECTION "클리닝정책(Cleaning Policy)" [26491-27420] -->
<h3 class="sectionedit12" id="부하제어_load_control">부하제어(Load Control)</h3>
<div class="level3">

<p>
부하제어는 주기억장치에 적재될 프로세스 수(멀티프로그래밍 수준)를 결정하는 것과 관련된다. 부하제어 정책은 메모리를 효과적으로 관리하는데 매우 중요하다. 
</p>

</div>

<h4 id="멀티프로그래밍_수준">멀티프로그래밍 수준</h4>
<div class="level4">

<p>
작업집합이나 PFF 알고리즘은 부하제어를 함축적으로 포함하고 있어, 단지 적재집합이 충분히 큰 프로세스들만 수행되도록 허용한다. 
</p>

</div>

<h4 id="프로세스_보류_process_suspension">프로세스 보류 (Process Suspension)</h4>
<div class="level4">

<p>
멀티 프로그램으이 차수를 감소시키려면, 현재 적재된 프로세스들 중 하나 이상을 보류(스왑-아웃)시켜야 한다. 보류시킬 프로세스 선택과 관련하여 다음 여섯 가지 가능성이 있다.
</p>
<ul>
<li class="level1"><div class="li"> 최저 우선순위 프로세스</div>
</li>
<li class="level1"><div class="li"> 폴트 발생 프로세스</div>
</li>
<li class="level1"><div class="li"> 가장 최근에 활성화된 프로세스</div>
</li>
<li class="level1"><div class="li"> 최소 적재집합을 가진 프로세스</div>
</li>
<li class="level1"><div class="li"> 가장 큰 프로세스</div>
</li>
<li class="level1"><div class="li"> 잔여 수행 윈도우가 가장 큰 프로세스</div>
</li>
</ul>

</div>
<!-- EDIT12 SECTION "부하제어(Load Control)" [27421-] -->