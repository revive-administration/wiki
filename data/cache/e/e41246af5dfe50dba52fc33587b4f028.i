a:211:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"4장 채널 파이프라인과 코덱";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:283:"채널 파이프라인은 채널에서 발생한 이벤트가 이동하는 통로다. 이 통로를 통해서 이동하는 이벤트를 처리하는 클래스를 이벤트 핸들러라고 하며 이벤트 핸들러를 상속받아서 구현한 구현체들을 코덱이라고 한다.";}i:2;i:53;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:336;}i:6;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:338;}i:7;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"4.1 이벤트 실행";i:1;i:2;i:2;i:338;}i:2;i:338;}i:8;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:338;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:371;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"4.2 채널 파이프라인";i:1;i:2;i:2;i:371;}i:2;i:371;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:371;}i:12;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:410;}i:13;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"4.2.1 채널 파이프라인의 구조";i:1;i:3;i:2;i:410;}i:2;i:410;}i:14;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:410;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:410;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:288:"채널은 일반적인 소켓 프로그래밍에서 말하는 소켓과 같다고 보는데 이 소켓에서 발생한 이벤트는 채널 파이프라인을 따라 흐른다. 채널에서 발생한 이벤트들을 수신하고 처리하는 기능은 이벤트 핸들러가 수행한다. ";}i:2;i:459;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:747;}i:18;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:749;}i:19;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"4.2.2 채널 파이프라인의 동작";i:1;i:3;i:2;i:749;}i:2;i:749;}i:20;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:749;}i:21;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:749;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:371:"initChannel 메서드는 클라이언트 소켓 채널이 생성될 때 자동으로 호출되는데 이때 채널 파이프라인의 설정을 수행한다. 부트스트랩에 설정한 ChannelInitializer 클래스의 initChannel 메서드 본체는 부트스트랩이 초기화될 때 수행되며 이때 서버 소켓 채널과 채널 파이프라인이 연결된다. ";}i:2;i:798;}i:23;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1169;}i:24;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1171;}i:25;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"4.3 이벤트 핸들러";i:1;i:2;i:2;i:1171;}i:2;i:1171;}i:26;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1171;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1171;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:617:"네티는 비동기 호출을 지원하는 두 가지 패턴을 제공한다. 첫 번째는 퓨처 패턴이며 두 번째는 리액터 패턴의 구현체인 이벤트 핸들러다. 이벤트 핸들러는 네티의 소켓 채널에서 발생한 이벤트를 처리하는 인터페이스다. 소켓 채널의 이벤트를 인터페이스로 정의하고 이 인터페이스를 상속받은 이벤트 핸들러를 작성하여 채널 파이프라인에 등록한다. 채널 파이프라인으로 입력되는 이벤트를 이벤트 루프가 가로채어 이벤트에 해당하는 메서드를 수행하는 구조다. ";}i:2;i:1206;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1823;}i:30;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1825;}i:31;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:35:"4.3.1 채널 인바운드 이벤트";i:1;i:3;i:2;i:1825;}i:2;i:1825;}i:32;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1825;}i:33;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1825;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:357:"네티는 소켓 채널에서 발생하는 이벤트를 인바운드 이벤트와 아웃바운드 이벤트로 추상화한다. 인바운드 이벤트는 소켓 채널에서 발생한 이벤트 중에서 연결 상대방이 어떤 동작을 취했을 때 발생한다. 예를들면 채널 활성화, 데이터 수신 등의 이벤트가 이에 해당한다.";}i:2;i:1871;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2228;}i:36;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2230;}i:37;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"channelRegistered 이벤트";i:1;i:4;i:2;i:2230;}i:2;i:2230;}i:38;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:2230;}i:39;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2230;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:186:"채널이 이벤트 루프에 등록되었을 때 발생한다. 이벤트 루프는 네티가 이벤트를 실행하는 스레드로써 부트 스트랩에 설정한 이벤트 루프다.";}i:2;i:2266;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2452;}i:42;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2454;}i:43;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"channelActive 이벤트";i:1;i:4;i:2;i:2454;}i:2;i:2454;}i:44;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:2454;}i:45;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2454;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:352:"channelRegistered 이벤트 이후에 발생한다. 이는 채널이 생성되고 이벤트 루프에 등록된 이후에 네티 API를 사용하여 채널 입출력을 수행할 상태가 되었음을 알려주는 이벤트다. 서버 또는 클라이언트가 상대방에 연결한 직후에 한 번 수행할 작업을 처리하기에 적합하다.";}i:2;i:2486;}i:47;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2838;}i:48;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2840;}i:49;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"channelRead 이벤트";i:1;i:4;i:2;i:2840;}i:2;i:2840;}i:50;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:2840;}i:51;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2840;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:203:"데이터가 수신되었음을 알려준다. 수신된 데이터는 네티의 ByteBuf 객체에 저장되어 있으며 이벤트 메서드의 두 번째 인자인 msg를 통해서 접근할 수 있다. ";}i:2;i:2870;}i:53;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3073;}i:54;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3075;}i:55;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"channelReadComplete 이벤트";i:1;i:4;i:2;i:3075;}i:2;i:3075;}i:56;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3075;}i:57;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3075;}i:58;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:243:"데이터 수신이 완료되었음을 알려준다. channelRead 이벤트는 채널에 데이터가 있을 때 발생하고 채널의 데이터를다 읽어서 더 이상 데이터가 없을 때 channelReadComplete 이벤트가 발생한다. ";}i:2;i:3113;}i:59;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3356;}i:60;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3358;}i:61;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"channelInactive 이벤트";i:1;i:4;i:2;i:3358;}i:2;i:3358;}i:62;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3358;}i:63;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3358;}i:64;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:99:"채널이 비활성화 되었을 때 발생한다. 이후 입출력 작업을 수행할 수 없다.";}i:2;i:3392;}i:65;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3491;}i:66;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3493;}i:67;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"channelUnregistered 이벤트";i:1;i:4;i:2;i:3493;}i:2;i:3493;}i:68;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3493;}i:69;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3493;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:"채널이 이벤트 루프에서 제거되었을 때 발생한다. 이후 이벤트를 처리할 수 없다.";}i:2;i:3531;}i:71;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3639;}i:72;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3641;}i:73;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"4.2.3 아웃바운드 이벤트";i:1;i:3;i:2;i:3641;}i:2;i:3641;}i:74;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3641;}i:75;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3641;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:201:"소켓 채널에서 발생한 이벤트 중에서 네티 사용자가 요청한 동작에 해당하는 이벤트를 말하며 연결 요청, 데이터 전송, 소켓 닫기 등이 이에 해당한다. ";}i:2;i:3682;}i:77;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3884;}i:78;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3884;}i:79;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"bind 이벤트";i:1;i:4;i:2;i:3884;}i:2;i:3884;}i:80;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3884;}i:81;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3884;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:306:"서버 소켓 채널이 클라이언트의 연결을 대기하는 IP 포트가 설정되었을 때 발생한다. bind 이벤트에서는 서버 소켓 채널이 사용중인 SocketAddress 객체가 인수로 입력된다. 즉 서버 소켓 채널이 사용하는 IP와 포트정보를 확인할 수 있다.";}i:2;i:3907;}i:83;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4213;}i:84;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4215;}i:85;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"connect 이벤트";i:1;i:4;i:2;i:4215;}i:2;i:4215;}i:86;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4215;}i:87;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4215;}i:88;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:198:"클라이언트와 소켓 채널이 서버에 연결되었을 때 발생한다. connect이벤트에서는 원격지의 SocketAddress 정보와 로컬 SocketAddress 정보가 인수로 입력된다. ";}i:2;i:4241;}i:89;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4439;}i:90;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4441;}i:91;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"disconnect 이벤트";i:1;i:4;i:2;i:4441;}i:2;i:4441;}i:92;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4441;}i:93;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4441;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"클라이언트 소켓 채널의 연결이 끊어졌을 때 발생한다.";}i:2;i:4470;}i:95;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4543;}i:96;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4545;}i:97;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"close 이벤트";i:1;i:4;i:2;i:4545;}i:2;i:4545;}i:98;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4545;}i:99;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4545;}i:100;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:70:"클라이언트 소켓 채널의 연결이 닫혔을 때 발생한다.";}i:2;i:4569;}i:101;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4639;}i:102;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4641;}i:103;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"write 이벤트";i:1;i:4;i:2;i:4641;}i:2;i:4641;}i:104;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4641;}i:105;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4641;}i:106;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:"소켓 채널에 데이터가 기록되었을 때 발생한다.";}i:2;i:4665;}i:107;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4728;}i:108;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4730;}i:109;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"flush 이벤트";i:1;i:4;i:2;i:4730;}i:2;i:4730;}i:110;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4730;}i:111;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4730;}i:112;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"소켓 채널에 대한 flush 메서드가 호출되었을 때 발생한다.";}i:2;i:4754;}i:113;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4830;}i:114;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4832;}i:115;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:59:"4.3.3 이벤트 이동 경로와 이벤트 메서드 실행";i:1;i:3;i:2;i:4832;}i:2;i:4832;}i:116;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4832;}i:117;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4832;}i:118;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:161:"ChannelHandlerContext 인터페이스의 fireChannelRead 메서드를 호출하면 네티는 채널 파이프라인에 channelRead 이벤트를 발생시킨다. ";}i:2;i:4902;}i:119;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5063;}i:120;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5065;}i:121;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"4.3.4 코덱";i:1;i:3;i:2;i:5065;}i:2;i:5065;}i:122;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5065;}i:123;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5065;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"네티에서 인코더는 전송할 데이터를 전송 프로토콜에 맞추어 변환 작업을 수행하고 디코더는 반대의 작업을 수행한다.";}i:2;i:5088;}i:125;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5246;}i:126;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5248;}i:127;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"4.4 코덱의 구조";i:1;i:2;i:2;i:5248;}i:2;i:5248;}i:128;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:5248;}i:129;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5281;}i:130;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"4.4.1 코덱의 실행 과정";i:1;i:3;i:2;i:5281;}i:2;i:5281;}i:131;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5281;}i:132;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5281;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"네티의 코덱은 템플릿 메서드 패턴으로 구현되어있다. ";}i:2;i:5321;}i:134;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5394;}i:135;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5396;}i:136;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"4.5 기본 제공 코덱";i:1;i:2;i:2;i:5396;}i:2;i:5396;}i:137;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:5396;}i:138;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5433;}i:139;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"base64 코덱";i:1;i:3;i:2;i:5433;}i:2;i:5433;}i:140;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5433;}i:141;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5433;}i:142;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"Base 64 인코딩 데이터에 대한 송수신을 지원하는 코덱이다. Base64란 '8비트 이진 데이터'를 '문자 코드에 영향을 받지 않는 공통 ";}i:2;i:5457;}i:143;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:5624;}i:144;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:" 영역의 문자로 이루어진 일련의 문자열'로 바꾸는 인코딩을 말한다.";}i:2;i:5629;}i:145;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5720;}i:146;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5722;}i:147;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"bytes 코덱";i:1;i:3;i:2;i:5722;}i:2;i:5722;}i:148;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5722;}i:149;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5722;}i:150;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"바이트 배열 데이터에 대한 송수신을 지원하는 코덱이다.";}i:2;i:5745;}i:151;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5821;}i:152;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5823;}i:153;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"compression 코덱";i:1;i:3;i:2;i:5823;}i:2;i:5823;}i:154;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5823;}i:155;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5823;}i:156;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"송수신 데이터의 압축을 지원하는 코덱이다. ";}i:2;i:5851;}i:157;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5911;}i:158;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5913;}i:159;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"http 코덱";i:1;i:3;i:2;i:5913;}i:2;i:5913;}i:160;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5913;}i:161;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5913;}i:162;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:116:"HTTP 프로토콜을 지원하는 코덱으로서 하위 패키지에서 다양한 송수신 방법을 지원한다.";}i:2;i:5935;}i:163;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6051;}i:164;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6053;}i:165;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"marshalling 코덱";i:1;i:3;i:2;i:6053;}i:2;i:6053;}i:166;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6053;}i:167;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6053;}i:168;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:"마샬링이란 객체를 네트워크를 통해서 송신 가능한 형태로 변환하는 과정이다. ";}i:2;i:6082;}i:169;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6188;}i:170;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6190;}i:171;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"protobuf 코덱";i:1;i:3;i:2;i:6190;}i:2;i:6190;}i:172;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6190;}i:173;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6190;}i:174;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:"구글의 프로토콜 버퍼를 사용한 데이터 송수신을 지원하는 코덱이다.";}i:2;i:6216;}i:175;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6308;}i:176;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6310;}i:177;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"rtsp 코덱";i:1;i:3;i:2;i:6310;}i:2;i:6310;}i:178;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6310;}i:179;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6310;}i:180;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:155:"RTSP는 오디오와 비디오 같은 실시간 데이터의 전달을 위해서 특수하게 만들어진 애플리케이션 레벨의 프로토콜이다.";}i:2;i:6332;}i:181;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6487;}i:182;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6489;}i:183;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"SCTP 코덱";i:1;i:3;i:2;i:6489;}i:2;i:6489;}i:184;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6489;}i:185;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6489;}i:186;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"tcp가 아닌 sctp 전송 계층을 사용하는 코덱이다.";}i:2;i:6511;}i:187;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6573;}i:188;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6575;}i:189;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"SPDY 코덱";i:1;i:3;i:2;i:6575;}i:2;i:6575;}i:190;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6575;}i:191;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6575;}i:192;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:"구글의 SPDY 프로토콜을 지원하는 코덱이다. ";}i:2;i:6596;}i:193;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6654;}i:194;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6656;}i:195;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"string 코덱";i:1;i:3;i:2;i:6656;}i:2;i:6656;}i:196;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6656;}i:197;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6656;}i:198;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:"문자열의 송수신을 지원하는 코덱이다.";}i:2;i:6680;}i:199;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6732;}i:200;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6734;}i:201;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"serialization 코덱";i:1;i:3;i:2;i:6734;}i:2;i:6734;}i:202;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6734;}i:203;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6734;}i:204;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"자바의 객체를 네트워크로 전송할 수 있도록 직렬화와 역직렬화를 지원하는 코덱이다.";}i:2;i:6765;}i:205;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6880;}i:206;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6882;}i:207;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"4.6 사용자 정의 코덱";i:1;i:2;i:2;i:6882;}i:2;i:6882;}i:208;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:6882;}i:209;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6922;}i:210;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:6922;}}