
<h1 class="sectionedit1" id="장_서비스_추상화">5장 서비스 추상화</h1>
<div class="level1">

<p>
스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 일관된 방법으로 사용할 수 있도록 지원하는가?! 이 장의 요지는 추상화로 기술이 바뀔때 이에 대한 대응과 그에 연관한 테스트 확장이다.
</p>

</div>
<!-- EDIT1 SECTION "5장 서비스 추상화" [1-310] -->
<h2 class="sectionedit2" id="사용자_레벨_관리_기능_추가">5.1 사용자 레벨 관리 기능 추가</h2>
<div class="level2">

<p>
인터넷 서비스의 사용자 관리 기능에서 구현해야 할 비즈니스 로직
</p>
<ul>
<li class="level1"><div class="li"> 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나이다.</div>
</li>
<li class="level1"><div class="li"> 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.</div>
</li>
<li class="level1"><div class="li"> 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.</div>
</li>
<li class="level1"><div class="li"> SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.</div>
</li>
<li class="level1"><div class="li"> 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.</div>
</li>
</ul>

<p>
사용자 관리의 기본 로직은 정해진 조건에 따라 사용자의 레벨을 주기적으로 변경한다는 간단한 내용이다.
</p>

</div>
<!-- EDIT2 SECTION "5.1 사용자 레벨 관리 기능 추가" [311-1174] -->
<h3 class="sectionedit3" id="필드_추가">5.1.1 필드 추가</h3>
<div class="level3">

</div>

<h4 id="level_이늄">Level 이늄</h4>
<div class="level4">

</div>

<h5 id="정수형_상수_값으로_사용자_레벨_설정">1. 정수형 상수 값으로 사용자 레벨 설정</h5>
<div class="level5">

<p>
타입이 int이기 때문에 다른 종류의 정보를 넣어도 컴파일러가 타입체크를 해주지 못한다.
</p>
<pre class="code">user1.setLevel(other.getSum())</pre>

<p>
또, 아래와 같이 범위를 벗어나는 값을 넣을 위험도 있다.
</p>
<pre class="code">user1.setLevel(1000);</pre>

<p>
따라서 숫자 타입을 사용하는 것보다는 JAVA5 이상에서 제공하는 ENUM을 이용하는게 안전하고 편리하다.  
</p>

<p>
이렇게 만들어진 Level 이늄은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다. user1.setLevel(1000)과 같은 코드는 타입이 일치하지 않는다는 에러를 내면서 걸러줄 것이다.
</p>

</div>

<h4 id="user_필드_추가">User 필드 추가</h4>
<div class="level4">

<p>
이렇게 만든 Level 타입의 변수를 User 클래스에 추가하자. 사용자 레벨 관리 로직에서 언급된 로그인 횟수 및 추천수도 추가하자.
</p>

</div>

<h4 id="userdaotest_테스트_수정">UserDaoTest 테스트 수정</h4>
<div class="level4">

<p>
UserDaoJdbc와 테스트에도 필드를 추가해야 한다. UserDaoJdbc는 테스트까지 갖고 있는 안정된 코드다. 기존 코드에 새로운 기능을 추가하려면 테스트를 먼저 만드는 것이 안전하다.
</p>

<p>
먼저 테스트 픽스처로 만든 user1, user2, user3에 새로 추가된 세 필드의 값을 넣는다.
</p>

<p>
다음은 UserDaoTest 테스트에서 두 개의 User 오브젝트 필드 값이 모두 같은지 비교하는 checkSameUser() 메서드를 수정한다. 검증용 필드를 추가해서 기존에 만들었던 DAO 테스트 기능을 보완하는 것이다. 이를 빼먹으면 새로 추가된 필드의 DB 쓰기와 읽기가 바르게 되는지 검증되지 않는다.
</p>

<p>
테스트는 이제 준비되었다. 하지만 테스트 대상인 UserDaoJdbc는 아직 수정하지 않았으니 지금 테스트를 돌리면 실패한다. 이를 끼워 맞추는 것이 TDD이다.
</p>

</div>

<h4 id="userdaojdbc_수정">UserDaoJdbc 수정</h4>
<div class="level4">

<p>
이제 UserDaoJdbc 클래스를 수정해보자. 등록을 위한 INSERT 문장이 들어 있는 add() 메서드의 SQL과 각종 조회 작업에 사용되는 User 오브젝트 매핑용 <a href="/dokuwiki/doku.php?id=%EC%BD%9C%EB%B0%B1" class="wikilink1" title="콜백">콜백</a>인 userMapper에 추가된 필드를 넣는다.
</p>

<p>
테스트를 돌려보면 테스트가 실패한다.
</p>

</div>
<!-- EDIT3 SECTION "5.1.1 필드 추가" [1175-3483] -->
<h3 class="sectionedit4" id="사용자_수정_기능_추가">5.1.2 사용자 수정 기능 추가</h3>
<div class="level3">

<p>
사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 수정할 정보가 담긴 User 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메서드를 하나 만들겠다.
</p>

</div>

<h4 id="수정_기능_테스트_추가">수정 기능 테스트 추가</h4>
<div class="level4">

<p>
만들어야 할 코드의 기능을 생각해볼 겸 리스트 5-10과 같은 테스트를 먼저 작성한다.
</p>

<p>
먼저 픽스처 오브젝트를 하나 등록한다. 그리고 id를 제외한 필드의 내용을 바꾼 뒤 update()를 호출한다. 이제 해당 id의 사용자 정보가 변경됐어야 한다. 다시 id로 조회해서 가져온 User 오브젝트와 수정한 픽스처 오브젝트를 비교한다.
</p>

<p>
그런데 user1이라는 텍스트 픽스처는 인스턴스 변수로 만들어놓은 것인데, 이를 직접 변경해도 될까? 상관없다. 어차피 테스트 메서드가 실행될때마다 새로 만들어지고 setUp() 메서드로 다시 불려서 초기화되기 때문이다.
</p>

</div>

<h4 id="userdao와_userdaojdbc_수정">UserDao와 UserDaoJdbc 수정</h4>
<div class="level4">

<p>
UserDao에 update() 메서드를 추가하고 구체적인 클래스에 해당 메서드를 구현한다.
</p>

</div>

<h4 id="수정_테스트_보완">수정 테스트 보완</h4>
<div class="level4">

<p>
JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 많은 실수가 일어나는 곳은 바로 SQL 문장이다. 특히 UPDATE 문장에서 WHERE 절을 빼먹는 경우는 아무런 경고 없이 정상적으로 동작하는 것처럼 보인다. 현재 update() 테스트는 수정할 로우의 내용이 바뀐 것만 확인할 뿐, 수정하지 않아야 할 로우의 내용이 그대로 남아 있는지는 확인해주지 못한다는 문제가 있다.
</p>

<p>
이 문제를 해결할 방법을 생각해보자. 첫 번째 방법은 JdbcTemplate의 update()가 돌려주는 리턴 값을 확인하는 것이다. JdbcTemplate의 update()는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 돌려준다. 지금까지는 이 정보를 무시해왓는데 이쯤에서 UserDao의 각 메소드들의 리턴 타입을 int로 바꾸고 이 정보를 리턴하게 만들 수 있다. 그러나 에러가 발생하지 않아도 영향받은 로우의 개수가 1이상이라면 문제가 있을 수 있다. 
</p>

<p>
두 번째 방법은 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다. 사용자를 두 명 등록해놓고 그 중 하나만 수정한 뒤에 수정된 사용자와 수정하지 않은 사용자의 정보를 모두 확인하면 된다.
</p>

<p>
update()메서드의 SQL에서 WHERE을 빼먹었다면 이 테스트는 실패로 끝날 것이다.
</p>

</div>
<!-- EDIT4 SECTION "5.1.2 사용자 수정 기능 추가" [3484-6270] -->
<h3 class="sectionedit5" id="userserviceupgradelevels">5.1.3 UserService.upgradeLevels()</h3>
<div class="level3">

<p>
사용자 관리 로직은 어디다 두는 것이 좋을까? UserDaoJdbc는 적당하지 않다. DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니다. 사용자 관리 비즈니스 로직을 담을 클래스를 하나 추가하자. 
</p>

<p>
UserServiceTest –(의존)–&gt; UserService –(의존)–&gt; UserDao ←-(구현)– UserDaoJdbc
</p>

</div>

<h4 id="userservice_클래스와_빈_등록">UserService 클래스와 빈 등록</h4>
<div class="level4">

<p>
UserServiceTest 클래스를 추가하고 테스트 대상인 UserService 빈을 제공받을 수 있도록 @Autowired가 붙은 인스턴스 변수로 선언해준다. UserService는 컨테이너가 관리하는 스프링 빈이므로 스프링 테스트 컨텍스트를 통해 주입받을 수 있다.
</p>

</div>

<h4 id="upgradelevels_메서드">upgradeLevels() 메서드</h4>
<div class="level4">

<p>
이번엔 사용자 레벨 관리 기능을 먼저 만들고 테스트를 만들어보자. changed 플래그를 확인해서 레벨 변경이 있는 경우에만 UserDao의 update()를 이용해 수정 내용을 DB에 반영한다.
</p>

</div>

<h4 id="upgradelevels_테스트">upgradeLevels() 테스트</h4>
<div class="level4">

<p>
테스트 방법을 생각해보자. 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 다섯 종류의 사용자 정보를 등록해두고 업그레이드를 진행한 후에 예상한 대로 결과가 나오는지 확인해보자.
</p>

<p>
텍스트 픽스처의 개수가 UserDaoTest에서보다 많아졌으니 이번에는 각각 변수로 등록하는 리스트를 사용해보자.
</p>

<p>
BASIC과 SILVER 레벨의 사용자는 경계가 되는 값의 전후를 테스트 해보기 위해 각각 두 개씩 등록했다. 리스트 5-20은 준비된 픽스처를 사용해 만든 테스트다.
</p>

<p>
테스트를 돌려보자. 성공이다.
</p>

</div>

<h4 id="userserviceadd">5.1.4 UserService.add()</h4>
<div class="level4">

<p>
사용자 관리 비즈니스 로직에서 아직 미구현한 기능이 남아있다. 처음 가입하는 사용자는 기본적으로 BASIC 레벨이어야 한다는 부분이다. 이 로직은 어디에 담는 것이 좋을까?
</p>

<p>
UserDao의 add() 메서드가 사용자 정보를 담은 User 오브젝트를 받아서 DB에 넣어주는 데 충실한 역할을 한다면, UserService에도 add()를 만들어두고 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 하면 될 것이다.
</p>

<p>
테스트부터 만들어보자. 검증할 기능은 UserService의 add()를 호출하면 레벨이 BASIC으로 설정되는 것이다. 그런데 User 오브젝트에 level 필드에 값이 미리 설정되어 있는 경우에는 어떻게 해야 할까? 이것은 정하기 나름이다.
</p>

<p>
레벨이 미리 정해진 경우와 레벨이 비어 있는 두 가지 경우에 각각 add() 메서드를 호출하고 결과를 확인하도록 만들자. User 오브젝트의 레벨이 변경되었는지 확인하기 위해 사용할 수 있는 두 가지 방법이 있다.
</p>

<p>
간단한 방법은 UserService의 add() 메서드를 호출할 때 파라미터로 넘긴 User 오브젝트에 level 필드를 확인해보는 것이고, 다른 방법은 UserDao의 get() 메서드를 이용해서 DB에 저장된 User 정보를 가져와 확인하는 것이다. UserService는 UserDao를 통해 DB에 사용자 정보를 저장하기 때문에 이를 확인해보는 게 가장 확실한 방법이다. 
</p>

<p>
리스트 5-21과 같이 테스트 코드를 만들어보자.
</p>

<p>
이제 레벨이 GOLD로 설정된 사용자와 레벨이 null인 사용자 오브젝트 두 개를 준비한다. 준비한 두 개의 사용자 오브젝트를 UserService의 add() 메서드를 통해 초기화 한 뒤에 DB에 저장되도록 만든다. 확인을 위해 DB에서 사용자 정보를 읽어온다. 레벨이 이미 설정되었던 것은 그대로 유지되어 있어야 하고, 레벨이 없던 것은 디폴트인 BASIC으로 설정되었는지 확인해준다.
</p>

<p>
테스트는 준비되었으니 테스트가 성공하도록 코드를 만들어보자. add() 메서드를 리스트 5-22처럼 만들자.
</p>

</div>
<!-- EDIT5 SECTION "5.1.3 UserService.upgradeLevels()" [6271-10244] -->
<h3 class="sectionedit6" id="코드_개선">5.1.5 코드 개선</h3>
<div class="level3">

<p>
깔끔한 코드를 추구하는 스프링 사용자답게 만들어진 코드를 다시 한번 검토해보자. 다음과 같은 질문을 해볼 필요가 있다.
</p>
<ul>
<li class="level1"><div class="li"> 코드에 중복된 부분은 없는가?</div>
</li>
<li class="level1"><div class="li"> 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?</div>
</li>
<li class="level1"><div class="li"> 코드가 자신이 있어야 할 자리에 있는가</div>
</li>
<li class="level1"><div class="li"> 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?</div>
</li>
</ul>

</div>

<h4 id="upgradelevels_메서드_코드의_문제점">upgradeLevels() 메서드 코드의 문제점</h4>
<div class="level4">

<p>
upgradeLevels()메서드의 문제점을 찾아보자. 일단 for문속의 if/else 블록들이 읽기 불편하다. 플래그를 두고 변경한 후 마지막에 이를 확인해서 업데이트를 진행하는 방법도 그리 깔끔해 보이지 않는다.
</p>

<p>
코드가 깔끔해 보이지 않는 이유는 성격이 다른 여러 가지 로직이 한데 섞여 있기 때문이다. 성격이 다른 두 가지 경우가 모두 한 곳에서 처리되는 것은 뭔가 이상하다. 제대로 만들려면 조건을 두 단계에 걸쳐서 비교해야 한다. 첫 단계에서는 레벨을 확인하고 각 레벨별로 다시 조건을 판단하는 조건식을 넣어야한다. 그러나 이렇게 만들면 코드는 더 복잡해질 것이다.
</p>

</div>

<h4 id="upgradelevels_리팩토링">upgradeLevels() 리팩토링</h4>
<div class="level4">

<p>
이제 코드를 리팩토링해보자. 가장 먼저 추상적인 레벨에서 로직을 작성해보자. 기존의 upgradeLevels() 메서드는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여 있다. 레벨을 업그레이드하는 작업의 기본 흐름만 리스트 5-23과 같이 먼저 만들어보자. 구체적인 구현에서 외부에 노출할 인터페이스를 분리하는 것과 마찬가지 작업이라고 생각하면 된다. 한번에 일괄 레벨업을 시키는 것보다는 다른 메서드에서 분기를 처리하여 각각 레벨업이 되도록 처리하면 추상적 로직과 구체적 로직을 분리할 수 있다. 이제 하나씩 구체적인 내용을 담은 메서드를 만들면 된다. 먼저 업그레이드가 가능한지를 알려주는 메서드인 canUpgradeLevel() 메서드를 만들어보자. 주어진 user에 대해 업그레이드가 가능하면 true, 가능하지 않으면 false를 리턴하면 된다. 상태에 따라서 업그레이드 조건만 비교하면 되므로, 역할과 책임이 명료해진다.
</p>

<p>
다음은 업그레이드 조건을 만족했을 경우 구체적으로 무엇을 할 것인가를 담고 있는 upgradeLevel() 메서드를 만들어보자. 레벨 업그레이드를 위한 작업은 사용자의 레벨을 다음 단계로 바꿔주는 것과 변경사항을 DB에 업데이트해주는 것이다. 물론 나중에 추후 작업이 추가될 수도 있다. 업그레이드용 메서드를 따로 분리해두면 나중에 작업 내용이 추가되더라도 어느 곳을 수정해야 할지가 명확해진다는 장점이 있다.
</p>

<p>
일단 리스트 5-25와 같이 메서드를 만들어보자.
</p>

<p>
이 메서드는 사용자 오브젝트의 레벨정보를 다음 단계로 변경하고, 변경된 오브젝트를 DB에 업데이트하는 두 가지 작업을 수행한다. 그런데 upgradeLevel() 메서드 코드가 다소 마음에 안든다. 다음 단계가 무엇인가 하는 로직과 그때 사용자 오브젝트의 구체적 필드를 변경해준다는 로직이 함께 있는데다, 너무 노골적으로 드러나 있다. 게다가 예외상황에 대한 처리가 없다. 레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자. 레벨의 순서를 굳이 UserService에 담아둘 이유가 없다. Level을 리스트 5-26과 같이 수정한다.
</p>

<p>
Level 이늄에 next라는 다음 단계 레벨 정보를 담을 수 있도록 필드를 추가한다. 다음 레벨이 무엇인지를 알고 싶다면 nextLevel() 메서드를 호출해준다. 이번에는 사용자 정보가 바뀌는 부분을 UserService 메서드에서 User로 옮겨보자. User의 내부 정보가 변경되는 것은 UserService보다는 User가 스스로 다루는게 적절하다.
</p>

<p>
먼저 Level의 nextLevel() 기능을 이용해 현재 레벨의 다음 단계가 무엇인지 확인한다. Level의 순서와 다음 단계 정보는 모두 Level 이늄에서 관리하기 떄문에, User는 Level 타입의 level 필드에게 다음 레벨이 무엇인지 알려달라고 요청해서 현재 레벨을 변경해주면 도니다. 단, 더 이상 업그레이드가 불가능한 경우는 스스로 예외상황에 대한 검증 기능을 갖고 있는 것이 안전한다.
</p>

<p>
객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구하는게 아니라 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다. 처음 구현했던 UserService의 upgradeLevels() 메서드는 User 오브젝트에서 데이터를 가져와서 그것을 가지고 User 오브젝트나 Level 이늄이 해야 할 작업을 대신 수행하고 직접 User 오브젝트의 데이터를 변경해버린다. 이보다는 UserService는 User에게 “레벨 업그레이드 작업을 해달라”고 요청하고, 또 User는 Level에게 “다음 레벨이 무엇인지 알려달라”고 요청하는 방식으로 동작하게 하는 것이 바람직하다.
</p>

</div>

<h4 id="user_테스트">User 테스트</h4>
<div class="level4">

<p>
User에 간단한 로직을 담은 메서드를 추가했으니 테스트를 만들어두자. 5-29는 User에 추가한 upgradeLevel() 메서드에 대한 테스트다.
</p>

<p>
<strong>User 클래스에 대한 테스트는 굳이 스프링의 테스트 컨텍스트를 사용하지 않아도 된다. User 오브젝트는 스프링이 IoC로 관리해주는 오브젝트가 아니기 때문이다.</strong> 컨테이너가 생성한 오브젝트를 @Autowired로 가져오는 대신 생성자를 호출해서 테스트할 User 오브젝트를 만들면 된다.
</p>

</div>

<h4 id="userservicetest_개선">UserServiceTest 개선</h4>
<div class="level4">

<p>
기존의 upgradeLevels() 테스트 코드는 테스트 로직이 분명하게 드러나지 않는것이 단점이었다. 테스트 코드만 봐서는 그것이 업그레이드된 경우를 테스트하려는 것인지 쉽게 파악이 안된다. 그에 반해 개선한 upgradeLevels() 테스트는 각 사용자에 대해 업그레이드를 확인하려는 것인지 아닌지가 좀더 이해하기 쉽게 true, false로 나타나 있어서 보기 좋다. 업그레이드에 조건에 있어서 중복 코드가 테스트에 나타나 있는데 이러한 중복도 제거해주자. 가장 좋은 방법은 정수형 상수로 변경하는 것이다.
</p>

</div>
<!-- EDIT6 SECTION "5.1.5 코드 개선" [10245-] -->