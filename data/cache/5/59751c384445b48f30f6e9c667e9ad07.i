a:321:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"Chapter 01 객체지향 모델링";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:49;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"1.1 모델링";i:1;i:2;i:2;i:49;}i:2;i:49;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:49;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"모델의 역할";}i:2;i:75;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:91;}i:9;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:91;}i:10;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:91;}i:11;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:91;}i:12;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:91;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:"서로의 해석을 공유해 합의를 이루거나 해석의 타당성을 검토한다";}i:2;i:96;}i:14;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:88:"서로의 해석을 공유해 합의를 이루거나 해석의 타당성을 검토한다";}i:2;i:96;}i:15;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:184;}i:16;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:184;}i:17;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:184;}i:18;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:184;}i:19;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:184;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"현재 시스템 또는 앞으로 개발할 시스템의 원하는 모습을 가시화한다.";}i:2;i:189;}i:21;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:93:"현재 시스템 또는 앞으로 개발할 시스템의 원하는 모습을 가시화한다.";}i:2;i:189;}i:22;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:282;}i:23;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:282;}i:24;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:282;}i:25;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:282;}i:26;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:282;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:"시스템의 구조와 행위를 명세화할 수 있으며 시스템을 구축하는 틀을 제공한다.";}i:2;i:287;}i:28;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:106:"시스템의 구조와 행위를 명세화할 수 있으며 시스템을 구축하는 틀을 제공한다.";}i:2;i:287;}i:29;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:393;}i:30;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:393;}i:31;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:393;}i:32;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:393;}i:33;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:394;}i:34;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:7:"1.2 UML";i:1;i:2;i:2;i:394;}i:2;i:394;}i:35;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:394;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:394;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:252:"UML은 요구 분석, 시스템 설계, 시스템 구현 등의 시스템 개발 과정에서 개발자 사이의 의사 소통이 원활하게 이루어지도록 표준화한 통합 모델링 언어다. 이 언어는 객체 관련 표준화 기구인 ";}i:2;i:414;}i:38;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"OMG";}i:2;i:666;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:182:"(Object Management Group)에서 1997년 11월 제임스 럼버의 객체 모델링 기술, 이바 야콥슨의 OOSE, 그래디 부치의 OOAD 방법론 등을 통합해 만들었다.";}i:2;i:669;}i:40;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:851;}i:41;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:851;}i:42;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:241:"현재 UML 2.0에서는 시스템의 구조와 동작을 표현하는 13개 다이어그램을 제공하는데, 이와 같이 많은 다이어그램을 제공하는 이유는 다양한 관점에서 시스템을 모델링하기 위함이다. ";}i:2;i:853;}i:43;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1094;}i:44;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1096;}i:45;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"1.3 클래스 다이어그램";i:1;i:2;i:2;i:1096;}i:2;i:1096;}i:46;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1096;}i:47;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1138;}i:48;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"1.3.1 클래스";i:1;i:3;i:2;i:1138;}i:2;i:1138;}i:49;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1138;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1138;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"표 1-2 접근 제어자";}i:2;i:1163;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1188;}i:53;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:3;i:1;i:5;i:2;i:1189;}i:2;i:1188;}i:54;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:1188;}i:55;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1188;}i:56;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1188;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" 접근 제어자 ";}i:2;i:1190;}i:58;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:1208;}i:59;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1208;}i:60;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 표시 ";}i:2;i:1209;}i:61;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:1217;}i:62;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1217;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 설명 ";}i:2;i:1218;}i:64;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:1226;}i:65;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:1227;}i:66;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:1227;}i:67;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1227;}i:68;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1227;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" public ";}i:2;i:1229;}i:70;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1237;}i:71;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1237;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" + ";}i:2;i:1238;}i:73;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1241;}i:74;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1241;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:" 어떤 클래스의 객체에서든 접근 가능 ";}i:2;i:1242;}i:76;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1293;}i:77;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:1294;}i:78;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1294;}i:79;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1294;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" private ";}i:2;i:1296;}i:81;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1305;}i:82;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1305;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" - ";}i:2;i:1306;}i:84;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1309;}i:85;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1309;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:" 이 클래스에서 생성된 객체들만 접근 가능 ";}i:2;i:1310;}i:87;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1368;}i:88;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:1369;}i:89;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1369;}i:90;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1369;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" protected ";}i:2;i:1371;}i:92;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1382;}i:93;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1382;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" # ";}i:2;i:1383;}i:95;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1386;}i:96;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1386;}i:97;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:" 이 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능 ";}i:2;i:1387;}i:98;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1506;}i:99;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:1507;}i:100;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1507;}i:101;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1507;}i:102;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" package(default) ";}i:2;i:1509;}i:103;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1527;}i:104;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1527;}i:105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" ~ ";}i:2;i:1528;}i:106;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1531;}i:107;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1531;}i:108;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:" 동일 패키지에 있는 클래스의 객체들만 접근 가능 ";}i:2;i:1532;}i:109;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1600;}i:110;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:1601;}i:111;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:1601;}i:2;i:1601;}i:112;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:131:"Keypoint : 클래스는 공통의 속성과 책임을 갖는 객체들의 집합이자 실제 객체를 생성하는 설계도다.
";}i:2;i:1602;}i:113;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1739;}i:114;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"1.3.2 관계";i:1;i:3;i:2;i:1739;}i:2;i:1739;}i:115;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1739;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1739;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"표 1-4 클래스들 사이의 관계";}i:2;i:1762;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1799;}i:119;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:6;i:2;i:1800;}i:2;i:1799;}i:120;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:1799;}i:121;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1799;}i:122;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1799;}i:123;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 관계 ";}i:2;i:1801;}i:124;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:1809;}i:125;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1809;}i:126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 설명 ";}i:2;i:1810;}i:127;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:1818;}i:128;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:1819;}i:129;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:1819;}i:130;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:1819;}i:131;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1819;}i:132;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:" 연관 관계(Association) ";}i:2;i:1821;}i:133;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:1849;}i:134;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:1849;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:220:" 클래스들이 개념상 서로 연결되었음을 나타낸다. 실선이나 화살표로 표시하며 보통은 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일 때 표시한다. ";}i:2;i:1850;}i:136;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2070;}i:137;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:2071;}i:138;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:2071;}i:139;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2071;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:" 일반화 관계(Generalization) ";}i:2;i:2073;}i:141;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2107;}i:142;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2107;}i:143;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:259:" 객체지향 개념에서는 상속 관계라고 한다. 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 이를 IS-A 관계라고 하며 UML에서는 일반화 관계로 모델링한다. 속이 빈 화살표를 사용해 표시한다. ";}i:2;i:2108;}i:144;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2367;}i:145;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:2368;}i:146;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:2368;}i:147;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2368;}i:148;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:"집합 관계(Composition, Aggregation) ";}i:2;i:2370;}i:149;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2410;}i:150;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2410;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:" 클래스들 사이의 전체 또는 부분 같은 관계를 나타낸다. 집약aggregation 관계와 합성composition 관계가 존재한다. ";}i:2;i:2411;}i:152;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2557;}i:153;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:2558;}i:154;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:2558;}i:155;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2558;}i:156;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:" 의존 관계(Dependency) ";}i:2;i:2560;}i:157;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2587;}i:158;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2587;}i:159;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:301:" 연관 관계와 같이 한 클래스가 다른 클래스에서 제공되는 기능을 사용할 때를 나타낸다. 차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안과 같은, 매우 짧은 시간만 유지된다는 점이다. 점선 화살표를 사용해 표시한다.";}i:2;i:2588;}i:160;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2889;}i:161;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:2890;}i:162;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:2890;}i:163;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2890;}i:164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" 실체화 관계(Realization) ";}i:2;i:2892;}i:165;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:2923;}i:166;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:2923;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:248:" 책임들의 집합인 이 인터페이스와 이 책임들을 실제로 실현한 클래스들 사이의 관계를 나타낸다. 상속과 유사하게 빈 삼각형을 사용하며 머리에 있는 실선대신 점선을 사용해 표시한다. ";}i:2;i:2924;}i:168;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:3172;}i:169;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:3173;}i:170;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:3173;}i:2;i:3173;}i:171;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3175;}i:172;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"연관 관계";i:1;i:4;i:2;i:3175;}i:2;i:3175;}i:173;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3175;}i:174;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3175;}i:175;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:"두 개념이 연관되어 있을 때는 UML 연관 관계를 사용해 자연스럽게 나타낼 수 있다.";}i:2;i:3197;}i:176;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3307;}i:177;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:157:"KeyPoint : 연관 관계의 역할 이름은 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있다.
";}i:2;i:3307;}i:178;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3307;}i:179;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:345:"양방향 연관관계는 UML에서 두 클래스를 연결한 선에 화살표를 사용하지 않는다. 즉, 두 클래스의 객체들이 서로의 존재를 인식한다는 의미다. 연관 관계를 나타내는 선에 숫자가 있으면 연관된 객체 수가 여러개라는 의미이다. 이를 다중성multiplicity이라고 한다.";}i:2;i:3470;}i:180;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3815;}i:181;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3815;}i:182;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"아래 표는 여러가지 형태의 다중성 표시 방법에 대한 설명이다.";}i:2;i:3817;}i:183;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3901;}i:184;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:9;i:2;i:3902;}i:2;i:3901;}i:185;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:3901;}i:186;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:3901;}i:187;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3901;}i:188;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" 다중성 표기 ";}i:2;i:3903;}i:189;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:3921;}i:190;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3921;}i:191;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 의미 ";}i:2;i:3922;}i:192;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:3930;}i:193;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:3931;}i:194;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:3931;}i:195;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:3931;}i:196;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3931;}i:197;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 1 ";}i:2;i:3933;}i:198;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:3936;}i:199;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3936;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" 엄밀하게 1";}i:2;i:3937;}i:201;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:3952;}i:202;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:3953;}i:203;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:3953;}i:204;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3953;}i:205;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" * ";}i:2;i:3955;}i:206;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:3958;}i:207;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3958;}i:208;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" 0 또는 그 이상 ";}i:2;i:3959;}i:209;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:3980;}i:210;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:3981;}i:211;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:3981;}i:212;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3981;}i:213;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" 0..* ";}i:2;i:3983;}i:214;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:3989;}i:215;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:3989;}i:216;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" 0 또는 그 이상 ";}i:2;i:3990;}i:217;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4011;}i:218;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:4012;}i:219;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:4012;}i:220;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4012;}i:221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"1..* ";}i:2;i:4014;}i:222;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4019;}i:223;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4019;}i:224;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" 1 이상 ";}i:2;i:4020;}i:225;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4030;}i:226;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:4031;}i:227;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:4031;}i:228;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4031;}i:229;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"0..1 ";}i:2;i:4033;}i:230;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4038;}i:231;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4038;}i:232;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" 0 또는 1 ";}i:2;i:4039;}i:233;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4051;}i:234;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:4052;}i:235;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:4052;}i:236;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4052;}i:237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" 2..5 ";}i:2;i:4054;}i:238;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4060;}i:239;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4060;}i:240;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" 2 ~ 5 중 하나 ";}i:2;i:4061;}i:241;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4079;}i:242;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:4080;}i:243;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:4080;}i:244;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4080;}i:245;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" 1,2,6 ";}i:2;i:4082;}i:246;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4089;}i:247;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4089;}i:248;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" 1 또는 2 또는 6 ";}i:2;i:4090;}i:249;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4111;}i:250;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:4112;}i:251;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:4112;}i:252;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4112;}i:253;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 1, 3..5";}i:2;i:4114;}i:254;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4122;}i:255;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:4122;}i:256;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:" 1 또는 3 ~ 5 중 하나 ";}i:2;i:4123;}i:257;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:4150;}i:258;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:4151;}i:259;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:4151;}i:2;i:4151;}i:260;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4153;}i:261;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"일반화 관계";i:1;i:4;i:2;i:4153;}i:2;i:4153;}i:262;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4153;}i:263;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4153;}i:264;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:425:"한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 사이에는 일반화 관계가 존재한다. 일반환 관계가 존재할 때 자식(또는 서브클래스)이라 불리는 클래스는 부모(또는 슈퍼 클래스)라 불리는 클래스로부터 속성과 연산을 물려받을 수 있다. 이 때문에 객체지향 개념에서는 일반화 관계를 상속 관계라고 한다.";}i:2;i:4178;}i:265;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4603;}i:266;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4603;}i:267;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:219:"UML에서 일반화 관계는 두 클래스를 연결하는 화살표의 끝에 빈삼각형 표시를 해 표현한다. 삼각형 표시가 있는 쪽은 부모 클래스, 반대쪽은 자식 클래스를 나타낸다.";}i:2;i:4605;}i:268;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4824;}i:269;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4826;}i:270;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"집합 관계";i:1;i:4;i:2;i:4826;}i:2;i:4826;}i:271;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4826;}i:272;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4826;}i:273;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:223:"집합 관계는 UML 연관 관계의 특별 경우로 전체와 부분의 관계를 명확하게 명시하고자 할 때 사용한다. 집약(aggregation)과 합성(composition) 두 종류의 집합 관계가 존재한다.";}i:2;i:4848;}i:274;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5071;}i:275;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5071;}i:276;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:505:"집약 관계는 한 객체가 다른 객체를 포함하는 것을 나타낸다. '전체', '부분'과의 관계며 '전체'를 가리키는 클래스 방향에 빈 마름모로 표시한다. 특히 부분을 나타내는 객체를 다른 객체와 공유할 수 있는 경우에 집약 관계로 나타낸다. 이때 전체 객체의 라이프타임과 부분 객체의 라이프타임은 독립적이다. 즉 전체 객체가 메모리에서 사라진다 해도 부분 객체는 사라지지 않는다.";}i:2;i:5073;}i:277;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5578;}i:278;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5578;}i:279;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:512:"합성 관계는 전체를 가리키는 클래스 방향에 채워진 마름모로 표시되며 부분 객체가 전체 객체에 속하는 관계다. 따라서 전체 객체가 사라지면 부분 객체도 사라지는 경우를 의미한다. 공유할 수 있는 객체를 사용할 경우에는 합성 관계가 아닌 집약 관계를 사용한다. 이때 부분 객체의 라이프타임은 전체 객체의 라이프타임에 의존한다. 즉, 전체 객체가 없어지면 부분 객체도 없어진다.";}i:2;i:5580;}i:280;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6093;}i:281;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:137:"Keypoint : 집약 관계와 합성 관계를 구분하려면 전체 객체와 부분 객체의 라이프타임 의존성을 살펴보라
";}i:2;i:6093;}i:282;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6236;}i:283;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"의존 관계";i:1;i:4;i:2;i:6236;}i:2;i:6236;}i:284;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:6236;}i:285;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6236;}i:286;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"일반적으로 한 클래스가 다른 클래스를 사용하는 경우는 다음과 같이 3가지가 있다.";}i:2;i:6258;}i:287;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6369;}i:288;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"ul";i:2;s:16:" class="extlist"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6369;}i:289;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6369;}i:290;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6369;}i:291;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6369;}i:292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"클래스의 속성에서 참조할 때";}i:2;i:6374;}i:293;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:39:"클래스의 속성에서 참조할 때";}i:2;i:6374;}i:294;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:6413;}i:295;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:6413;}i:296;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6413;}i:297;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6413;}i:298;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:6413;}i:299;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"연산의 인자로 사용될 때";}i:2;i:6418;}i:300;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:33:"연산의 인자로 사용될 때";}i:2;i:6418;}i:301;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:6451;}i:302;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:5:"
  * ";}i:2;i:6451;}i:303;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:2:"li";i:2;s:0:"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6451;}i:304;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:1;i:1;s:3:"div";i:2;s:10:"class="li"";}i:2;i:1;i:3;s:5:"
  * ";}i:2;i:6451;}i:305;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:2;i:3;s:5:"
  * ";}i:2;i:6451;}i:306;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:50:"메서드 내부의 지역 객체로 참조될 때";}i:2;i:6456;}i:307;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:3;i:3;s:50:"메서드 내부의 지역 객체로 참조될 때";}i:2;i:6456;}i:308;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:3:"div";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:6506;}i:309;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"li";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:6506;}i:310;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;a:3:{i:0;i:4;i:1;s:2:"ul";i:2;s:0:"";}i:2;i:4;i:3;s:1:"
";}i:2;i:6506;}i:311;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:7:"extlist";i:1;b:1;i:2;i:4;i:3;s:1:"
";}i:2;i:6506;}i:312;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:139:"연관 관계는 오랜 시간 동안 같이할 객체와의 관계이며 의존 관계는 짧은 시간 동안 이용하는 관계이다.
";}i:2;i:6507;}i:313;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6652;}i:314;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:35:"인터페이스와 실체화 관계";i:1;i:4;i:2;i:6652;}i:2;i:6652;}i:315;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:6652;}i:316;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6652;}i:317;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:325:"인터페이스란 책임(responsibility)이다. 어떤 객체의 책임이란 객체가 해야 하는 일로서 해석할 수 있고 어떤 경우에는 객체가 할 수 있는 일로도 해석할 수 있다. 즉, 객체가 외부에 제공하는 서비스나 기능은 객체가 수행하는 책임으로 보는 것이다.";}i:2;i:6696;}i:318;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7021;}i:319;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7022;}i:320;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:7022;}}