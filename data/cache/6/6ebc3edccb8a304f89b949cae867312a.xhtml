
<h1 class="sectionedit1" id="장_그래프">9장. 그래프</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "9장. 그래프" [1-30] -->
<h2 class="sectionedit2" id="그래프의_구조">01 그래프의 구조</h2>
<div class="level2">

<p>
그래프는 연결되어 있는 원소간의 관계를 표현하는 자료구조다. 버스 노선도나 전철 노선도를 보면 여러 지역이 어떻게 연결되어 있는지를 알 수 있다. 그래프는 연결할 객체를 나타내는 정점(vertex)와 객체를 연선하는 간선(edge)의 집합으로 구성된다. 그래프 G를 G=(V,E)로 정의하는데, V는 그래프에 있는 정점들의 집합을 의미하고 E는 정점을 연결하는 간선들의 집합을 의미한다.
</p>

</div>
<!-- EDIT2 SECTION "01 그래프의 구조" [31-567] -->
<h3 class="sectionedit3" id="그래프의_종류">(1) 그래프의 종류</h3>
<div class="level3">

<p>
그래프는 방향성과 연결 정도에 따라 여러 형태가 있다.
</p>

</div>

<h4 id="무방향_그래프">무방향 그래프</h4>
<div class="level4">

<p>
무방향 그래프는 두 정점을 연결하는 간선의 방향이 없는 그래프이다. 
</p>

</div>

<h4 id="방향_그래프">방향 그래프</h4>
<div class="level4">

<p>
방향 그래프는 다이그래프라고도 하는데, 간선에 방향이 있는 그래프이다. Vi→Vj를 &lt;Vi, Vj&gt;로 표현하고 화살표로 나타낸다. Vi를 꼬리, Vj를 머리(head)라고 한다. 
</p>

</div>

<h4 id="완전_그래프">완전 그래프</h4>
<div class="level4">

<p>
완전 그래프(complete graph)는 각 정점에서 다른 모든 정점을 연결하여 가능한 최대의 간선 수를 가진 그래프이다. 정점이 n개인 무방향 그래프에서는 최대 간선 수가 n(n-1)/2개고, 방향 그래프에서는 두 정점에 대해서 방향이 다른 두 개의 간선을 연결할 수 있으므로 최대 간선 수의 2배가 되어 n(n-1) 개가 된다. 
</p>

</div>

<h4 id="부분_그래프">부분 그래프</h4>
<div class="level4">

<p>
원래의 그래프에서 일부의 정점이나 간선을 제외하여 만든 그래프를 부분 그래프(subgraph)라고 한다. 그래프G와 부분 그래프 g&#039;는 다음의 관계를 갖는다. 
</p>

</div>

<h4 id="가중_그래프">가중 그래프</h4>
<div class="level4">

<p>
w정점을 연결하는 간선에 가중치(weight)를 할당한 그래프를 가중 그래프 또는 네트워크 라고 한다.
</p>

</div>
<!-- EDIT3 SECTION "(1) 그래프의 종류" [568-1853] -->
<h3 class="sectionedit4" id="그래프_관련_용어">(2) 그래프 관련 용어</h3>
<div class="level3">

<p>
그래프에서 두 정점 Vi와 Vj가 연결되어 간선(Vi, Vj)가 있을 때 두 정점 Vi과 Vj를 인접되어 있다고 하고, 간선 (Vi, Vj)는 정점 Vi와 Vj에 부속(incident)되어 있다고 한다. 
</p>

<p>
정점에 부속되어 있는 간선의 수를 차수(degree)라고 한다. 
</p>

<p>
모두 다른 정점으로 구성된 경로를 단순 경로라고 한다. 단순 경로 중에서 경로의 시작 정점과 마지막 정점이 같은 경로를 사이클이라 한다. 방향 그래프이면서 사이클이 없는 그래프를 DAG(Directed Acyclic Graph)라고 한다.
</p>

<p>
그래프에서 두 정점 Vi에서 Vj까지의 경로가 있으면 정점 Vi와 Vj가 연결(connected)되었다고 한다. 서로 다른 모든 쌍의 정점들 사이에 있는 그래프, 즉 떨어져 있는 정점이 없는 그래프를 연결 그래프라고 한다. 트리는 사이클이 없는 연결 그래프다.
</p>

</div>
<!-- EDIT4 SECTION "(2) 그래프 관련 용어" [1854-2799] -->
<h3 class="sectionedit5" id="추상_자료형_그래프">(3) 추상 자료형 그래프</h3>
<div class="level3">
<pre class="code">ADT Graph
  데이터 : 공백이 아닌 정점의 집합과 간선의 집합&#039;
  연산 : g ∈ Graph; u,v ∈ V;
    createGraph() ::= create an empty Graph;
    isEmpty(g) ::= if (g have no vertex) then return true;
      else return false;
    insertVertex(g,v) ::= insert vertex v into g;
    insertEdge(g, u, v) ::= insert edge (u,v) into g;
    deleteVertex(g, v) ::= delete vertex v and all edges incident on v from g;
    deleteEdge(g, u, v) ::= delete edges (u,v) from g;
    adjacent(g, v) ::= return set of all vertices adjacent to v;
    </pre>

<p>
공백 그래프는 정점이 하나도 없는 그래프가 된다. 정점이 없으면 간선도 있을 수 없으므로 그래프 내에 정점의 유무를 검사하면 공백 그래프 여부를 알 수 있다.
</p>

</div>
<!-- EDIT5 SECTION "(3) 추상 자료형 그래프" [2800-3631] -->
<h2 class="sectionedit6" id="그래프의_구현">02 그래프의 구현</h2>
<div class="level2">

<p>
그래프를 구현하기 위해서는 정점에 대한 집합과 정점에 부속된 간선의 집합을 표현해야 한다. 그래프를 표현하는 방법은 순차 자료구조를 이용하는 2차원 배열의 인접 행렬 방법과 연결 자료구조인 연결 리스트를 사용하는 인접 리스트(adjacent list)방법이 있다. 
</p>

</div>
<!-- EDIT6 SECTION "02 그래프의 구현" [3632-4014] -->
<h3 class="sectionedit7" id="인접_행렬">(1) 인접 행렬</h3>
<div class="level3">

<p>
그래프를 구성하는 정점에 대해서 두 정점을 연결한 간선의 유무를 저장하는 방법으로 정점의 수에 대한 정방 행렬을 사용한다. n개의 정점을 가진 그래프는 각 정점에 대한 행과 열을 나타내야 하므로 n X n 정방 행렬이 되고, 두 정점이 인접되어 있으면 1, 인접되어 있지 않으면 0으로 표현한다.
</p>

<p>
그래프에서 하나의 정점에서 자기 자신으로의 자체간선은 있을 수 없으므로 인접 행렬의 대각선은 항상 0이다. 무방향 그래프에서 인접행렬은 대각선을 중심으로 윗부분과 아랫부분이 대칭이다. 방향 그래프에서는 간선의 위치가 다르면 서로 다른 간선이기 때문에 인접행렬이 대칭이 되지 않는다. 방향 그래프에 대한 인접 행렬에서 행 i의 합은 정점 i의 진출 차수고, 열i의 합은 정점 i의 진입차수다.
</p>

<p>
n개의 정점을 가지는 그래프를 n x n 인접 행렬로 표현하면 간선의 개수에 상관없이 항상 n x n개의 메모리를 사용한다. 그래프에 간선이 많은 경우에는 큰 문제가 없겠지만, 정점의 개수에 비해서 간선의 개수가 적은 희소 그래프인 경우에는 인접 행렬이 희소 행렬이 되므로 메모리가 많이 낭비된다.
</p>

<p>
아래는 그래프 G1~G4를 인접 행렬로 표현한 C 프로그램이다.
</p>

<p>
(생략)
</p>

</div>
<!-- EDIT7 SECTION "(1) 인접 행렬" [4015-5452] -->
<h3 class="sectionedit8" id="인접_리스트">(2) 인접 리스트</h3>
<div class="level3">

<p>
인접 리스트로 그래프를 표현하는 방법은 각 정점에 대한 인접 정점들을 연결 리스트로 만드는 것이다. 리스트의 각 노드는 정점을 저장하는 필드와 다음 인접 정점을 연결하는 링크 필드로 구성된다. 어떤 정점의 연결리스트는 그 정점에 인접한 정점의 수만큼 즉, 그 정점의 차수만큼 노드가 연결되어 있다. 리스트 내의 노드는 저장하는 정점에 대하여 오름차순으로 연결한다.
</p>

<p>
n개의 정점과 e개의 간선을 가진 무방향 그래프에 대한 인접 리스트는 크기가 n인 헤드 노드 배열과 2e개의 노드가 필요하다. n개의 정점을 가진 방향 그래프에 대한 인접리스트에서도 크기가 n인 헤드 노드 배열이 필요하고, 각 헤드 노드에 연결되는 노드의 수는 각 정점의 진출차수가 된다
</p>

</div>
<!-- EDIT8 SECTION "(2) 인접 리스트" [5453-6370] -->
<h2 class="sectionedit9" id="그래프_순회">03 그래프 순회</h2>
<div class="level2">

<p>
하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 그래프 탐색이라고 한다. 그래프 탐색 방법에는 깊이 우선 탐색과 너비 우선 탐색이 있다.
</p>

</div>
<!-- EDIT9 SECTION "03 그래프 순회" [6371-6650] -->
<h3 class="sectionedit10" id="깊이_우선_탐색">(1) 깊이 우선 탐색</h3>
<div class="level3">

<p>
깊이 우선 탐색(DFS, Depth First Search)은 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해가다가 더이상 갈 곳이 없으면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 간선으로 탐색을 계속하여 결국 모든 정점을 방문하는 순회 방식이다. 가장 마지막에 만났던 갈림길 간선의 정점으로 가장 먼저 되돌아가 다시 깊이 우선 탐색을 반복해야 하므로 후입 선출 구조의 스택을 사용한다.
</p>

<p>
깊이 우선 탐색의 수행 순서를 정리하면 다음과 같다.
</p>
<pre class="code">(1) 시작 정점 v를 결정하여 방문한다.
(2) 정점 v에 인접한 정점 중에서
  1) 방문하지 않은 정점 w가 있으면 정점 v를 스택에 push하고 w를 방문한다. 그리고 w를 v로 하여 다시 (2)를 반복한다.
  2) 방문하지 않은 정점이 없으면 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 설정한 뒤 다시 (2)를 수행한다.
(3) 스택이 공백이 될 때까지 (2)를 반복한다.</pre>

<p>
각 정점들에 대해서 방문 여부를 표시하기 위해서 배열 visited를 사용하기로 하자. 그래프의 정점의 개수를 배열 visited의 크기로 하고 모든 배열 요소를 FALSE로 초기화한다. 그리고 정점을 방문할 때마다 정점의 배열 요솟값을 TRUE로 설정한다.
</p>

<p>
깊이 우선 탐색을 알고리즘으로 정의하면 다음과 같다.
</p>
<pre class="code">DFS(v)
	for(i&lt;-0; i&lt;n; i&lt;-i+1) do{
		visited[i]&lt;-false;
	}
	stack&lt;-createStack();
	visited[v]&lt;-true;
	v 방문;
	while(not isEmpty(stack))do{
		if(visited[v의 인접정점 w]=false) then{
			push(stack, v);
			visited[w]&lt;- true;
			w 방문;
			v&lt;-w;
		}else
			v&lt;-pop(stack);
	}
end DFS()</pre>

</div>

<h4 id="깊이_우선_탐색_과정">깊이 우선 탐색 과정</h4>
<div class="level4">
<dl class="file">
<dt><a href="/dokuwiki/doku.php?do=export_code&amp;id=9%EC%9E%A5._%EA%B7%B8%EB%9E%98%ED%94%84&amp;codeblock=0" title="조각 다운로드" class="mediafile mf_c">예제 9-3.c</a></dt>
<dd><pre class="code file C"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;memory.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="co2">#define MAX_VERTEX 10</span>
<span class="co2">#define FALSE 0</span>
<span class="co2">#define TRUE 1</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span> graphNode<span class="br0">&#123;</span>
	<span class="kw4">int</span> vertex<span class="sy0">;</span>
	<span class="kw4">struct</span> graphNode<span class="sy0">*</span> link<span class="sy0">;</span>
<span class="br0">&#125;</span>graphNode<span class="sy0">;</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span> graphType<span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy0">;</span>
	graphNode<span class="sy0">*</span> adjList_H<span class="br0">&#91;</span>MAX_VERTEX<span class="br0">&#93;</span><span class="sy0">;</span>
	<span class="kw4">int</span> visited<span class="br0">&#91;</span>MAX_VERTEX<span class="br0">&#93;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>graphType<span class="sy0">;</span>
&nbsp;
<span class="co1">/////// &lt;&lt; 스택 연산</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span> stackNode<span class="br0">&#123;</span>
	<span class="kw4">int</span> data<span class="sy0">;</span>
	<span class="kw4">struct</span> stackNode <span class="sy0">*</span>link
<span class="br0">&#125;</span>stackNode<span class="sy0">;</span>
&nbsp;
stackNode<span class="sy0">*</span> pop<span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> push<span class="br0">&#40;</span><span class="kw4">int</span> item<span class="br0">&#41;</span><span class="br0">&#123;</span>
	stackNode<span class="sy0">*</span> temp <span class="sy0">=</span> <span class="br0">&#40;</span>stackNode <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span>stackNode<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	temp<span class="sy0">-&gt;</span>data <span class="sy0">=</span> item<span class="sy0">;</span>
	temp<span class="sy0">-&gt;</span>link <span class="sy0">=</span> top<span class="sy0">;</span>
	top <span class="sy0">=</span> temp<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> pop<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw4">int</span> item<span class="sy0">;</span>
	stackNode<span class="sy0">*</span> temp<span class="sy0">=</span>top<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span>top<span class="sy0">==</span>NULL<span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span><span class="es1">\n</span> Stack is empty !<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">else</span><span class="br0">&#123;</span>
		item <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>data<span class="sy0">;</span>
		top <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>link<span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>temp<span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span> item<span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">////// 스택 연산 &gt;&gt;</span>
&nbsp;
<span class="kw4">void</span> createGraph<span class="br0">&#40;</span>grapyType<span class="sy0">*</span> g<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw4">int</span> v<span class="sy0">;</span>
	g<span class="sy0">-&gt;</span>n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">&#40;</span>v<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> v<span class="sy0">&lt;</span>MAX_VERTEX<span class="sy0">;</span>v<span class="sy0">++</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
		g<span class="sy0">-&gt;</span>visited<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy0">=</span> FALSE<span class="sy0">;</span>
		g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy0">=</span>NULL<span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> insertVertex<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="sy0">,</span> <span class="kw4">int</span> v<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>g<span class="sy0">-&gt;</span>n<span class="br0">&#41;</span><span class="sy0">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">&gt;</span>MAX_VERTEX<span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span> 그래프 정점의 개수를 초과하였습니다!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	g<span class="sy0">-&gt;</span>n<span class="sy0">++;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> insertEdge<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="sy0">,</span> <span class="kw4">int</span> y<span class="sy0">,</span> <span class="kw4">int</span> v<span class="br0">&#41;</span><span class="br0">&#123;</span>
	graphNode<span class="sy0">*</span> node<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span>u<span class="sy0">&gt;=</span>g<span class="sy0">-&gt;</span>n <span class="sy0">||</span> v<span class="sy0">&gt;=</span>g<span class="sy0">-&gt;</span>n<span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span> 그래프에 없는 정점입니다!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	node <span class="sy0">=</span> <span class="br0">&#40;</span>graphNode <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span>graphNode<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	node<span class="sy0">-&gt;</span>vertex <span class="sy0">=</span> v<span class="sy0">;</span>
	node<span class="sy0">-&gt;</span>link <span class="sy0">=</span> g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>u<span class="br0">&#93;</span><span class="sy0">;</span>
	g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy0">=</span> node<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> print_adjList<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
	graphNode<span class="sy0">*</span> p<span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">&#40;</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>g<span class="sy0">-&gt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span><span class="es1">\t</span><span class="es1">\t</span>정점%c의 인접리스트&quot;</span><span class="sy0">,</span> i <span class="sy0">+</span><span class="nu0">65</span><span class="br0">&#41;</span><span class="sy0">;</span>
		p<span class="sy0">=</span>g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
		<span class="kw1">while</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="br0">&#123;</span>
			<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot; -&gt; %c&quot;</span><span class="sy0">,</span> p<span class="sy0">-&gt;</span>vertex <span class="sy0">+</span> <span class="nu0">65</span><span class="br0">&#41;</span><span class="sy0">;</span>
			p<span class="sy0">=</span>p<span class="sy0">-&gt;</span>link<span class="sy0">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> DFS_adjList<span class="br0">&#40;</span>graphType<span class="sy0">*</span>g <span class="kw4">int</span> v<span class="br0">&#41;</span><span class="br0">&#123;</span>
	graphNode<span class="sy0">*</span> w<span class="sy0">;</span>
	top <span class="sy0">=</span> NULL<span class="sy0">;</span>
	push<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy0">;</span>
	g<span class="sy0">-&gt;</span>visited<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy0">=</span> TRUE<span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot; %c&quot;</span><span class="sy0">,</span> v<span class="sy0">+</span><span class="nu0">65</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">&#40;</span>top <span class="sy0">!=</span>NULL<span class="br0">&#41;</span><span class="br0">&#123;</span>
		w<span class="sy0">=</span>g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy0">;</span>
		<span class="kw1">while</span><span class="br0">&#40;</span>w<span class="br0">&#41;</span><span class="br0">&#123;</span> <span class="co1">//인접정점이 있는 동안 수행</span>
			<span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">!</span>g<span class="sy0">-&gt;</span>visited<span class="br0">&#91;</span>w<span class="sy0">-&gt;</span>vertex<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
				push<span class="br0">&#40;</span>w<span class="sy0">-&gt;</span>vertex<span class="br0">&#41;</span><span class="sy0">;</span>
				g<span class="sy0">-&gt;</span>visited<span class="br0">&#91;</span>w<span class="sy0">-&gt;</span>vertex<span class="br0">&#93;</span> <span class="sy0">=</span> TRUE<span class="sy0">;</span>
				<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot; %c&quot;</span><span class="sy0">,</span> w<span class="sy0">-&gt;</span>vertex <span class="sy0">+</span><span class="nu0">65</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// 정점 0~6을 A~G로 바꾸어서 출력</span>
				v <span class="sy0">=</span> w<span class="sy0">-&gt;</span>vertex<span class="sy0">;</span>
				w<span class="sy0">=</span>g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy0">;</span>
			<span class="br0">&#125;</span><span class="kw1">else</span>
				w <span class="sy0">=</span> w<span class="sy0">-&gt;</span>link<span class="sy0">;</span>
		<span class="br0">&#125;</span>
		v <span class="sy0">=</span> pop<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
	graphType<span class="sy0">*</span> G9<span class="sy0">;</span>
	G9 <span class="sy0">=</span> <span class="br0">&#40;</span>graphType <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span>graphType<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	createGraph<span class="br0">&#40;</span>G9<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">&#40;</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span><span class="nu0">7</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
		insertVertex<span class="br0">&#40;</span>G9<span class="sy0">,</span> i<span class="br0">&#41;</span><span class="sy0">;</span>
	insertEdge<span class="br0">&#40;</span>G9<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">;</span>
	insertEdge<span class="br0">&#40;</span>G9<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
	insertEdge<span class="br0">&#40;</span>...<span class="br0">&#41;</span>
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT10 SECTION "(1) 깊이 우선 탐색" [6651-10827] -->
<h3 class="sectionedit11" id="너비_우선_탐색">(2) 너비 우선 탐색</h3>
<div class="level3">

<p>
너비 우선 탐색(BFS, Breadth First Search)은 시작 정점으로부터 인접한 정점들을 모두 차례로 방문하고 나서 방문했던 정점을 시작으로 다시 인접한 정점들을 차례로 방문하여 가까운 정점들을 먼저 방문하고 멀리 있는 정점들은 나중에 방문하는 순회 방법이다. 인접한 정점들에 대해서 차례로 다시 너비 우선 탐색을 반복해야 하므로 선입 선출의 구조를 갖는 큐를 사용한다.
</p>

<p>
너비 우선 탐색의 수행 순서를 정리하면 다음과 같다.
</p>
<pre class="code">(1) 시작 정점 v를 결정하여 방문한다.
(2) 정점 v에 인접한 정점들 중에서 방문하지 않은 정점을 차례로 방문하면서 큐에 enQueue 한다.
(3) 방문하지 않은 인접한 정점이 없으면 방문했던 정점에서 인접한 정점들을 다시 차례로 방문하기 위해 큐에서 deQueue하여 (2)를 반복한다.
(4) 큐가 공백이 될 때까지 (2)~(3)을 반복한다.</pre>

<p>
다음은 너비 우선 탐색을 정의한 알고리즘이다.
</p>
<pre class="code">BFS(v)
	for(i&lt;-0; i&lt;n; i&lt;i+1)do{
		visited[i]&lt;-false;
	}
	Q&lt;-createQueue();
	visited[v]&lt;-true;
	v 방문;
	while(not isEmpty(Q))do{
		while(visited[v의 인접정점 w]=false)do{
			visited[w]&lt;-true;
			w 방문;
			enQueue(Q,w);
		}
		v&lt;-deQueue(Q);
	}
end BFS()</pre>
<dl class="file">
<dt><a href="/dokuwiki/doku.php?do=export_code&amp;id=9%EC%9E%A5._%EA%B7%B8%EB%9E%98%ED%94%84&amp;codeblock=1" title="조각 다운로드" class="mediafile mf_c">너비우선탐색플그램.c</a></dt>
<dd><pre class="code file C"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;memory.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="co2">#define MAX_VERTEX 10</span>
<span class="co2">#define FALSE 0</span>
<span class="co2">#define TRUE 1</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span> graphNode<span class="br0">&#123;</span>
	<span class="kw4">int</span> vertex<span class="sy0">;</span>
	<span class="kw4">struct</span> graphNode<span class="sy0">*</span> link<span class="sy0">;</span>
<span class="br0">&#125;</span>graphNode<span class="sy0">;</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span> graphType<span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy0">;</span>
	graphNode<span class="sy0">*</span> adjList_H<span class="br0">&#91;</span>MAX_VERTEX<span class="br0">&#93;</span><span class="sy0">;</span>
	<span class="kw4">int</span> visited<span class="br0">&#91;</span>MAX_VERTEX<span class="br0">&#93;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>graphType<span class="sy0">;</span>
&nbsp;
<span class="co1">/////// &lt;&lt; 큐연산</span>
<span class="kw4">typedef</span> <span class="kw4">struct</span> QNode<span class="br0">&#123;</span>
	<span class="kw4">int</span> data<span class="sy0">;</span>
	<span class="kw4">struct</span> QNode <span class="sy0">*</span>link<span class="sy0">;</span>
<span class="br0">&#125;</span>QNode<span class="sy0">;</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span><span class="br0">&#123;</span>
	QNode <span class="sy0">*</span>front<span class="sy0">,</span> <span class="sy0">*</span>rear<span class="sy0">;</span>
<span class="br0">&#125;</span>LQueueType<span class="sy0">;</span>
&nbsp;
LQueueType <span class="sy0">*</span>createLinkedQueue<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
	LQueueType <span class="sy0">*</span>LQ<span class="sy0">;</span>
	LQ <span class="sy0">=</span> <span class="br0">&#40;</span>LQueueType <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span>LQueueType<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	LQ<span class="sy0">-&gt;</span>front<span class="sy0">=</span>NULL<span class="sy0">;</span>
	LQ<span class="sy0">-&gt;</span>rear<span class="sy0">=</span>NULL<span class="sy0">;</span>
	<span class="kw1">return</span> LQ<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> isEmpty<span class="br0">&#40;</span>LQueueType <span class="sy0">*</span>LQ<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span>LQ<span class="sy0">-&gt;</span>front <span class="sy0">==</span> NULL<span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span> Linked Queue is empty! <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">else</span> 
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> enQueue<span class="br0">&#40;</span>LQueueType <span class="sy0">*</span>LQ<span class="sy0">,</span> <span class="kw4">int</span> item<span class="br0">&#41;</span><span class="br0">&#123;</span>
	QNode <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">&#40;</span>QNode <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span>QNode<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	newNode<span class="sy0">-&gt;</span>data <span class="sy0">=</span> item<span class="sy0">;</span>
	newNode<span class="sy0">-&gt;</span>link <span class="sy0">=</span> NULL<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span>LQ<span class="sy0">-&gt;</span>front <span class="sy0">==</span> NULL<span class="br0">&#41;</span><span class="br0">&#123;</span>
		LQ<span class="sy0">-&gt;</span>front <span class="sy0">=</span> newNode<span class="sy0">;</span>
		LQ<span class="sy0">-&gt;</span>read <span class="sy0">=</span> newNode<span class="sy0">;</span>
	<span class="br0">&#125;</span><span class="kw1">else</span><span class="br0">&#123;</span>
		LQ<span class="sy0">-&gt;</span>rear<span class="sy0">-&gt;</span>link <span class="sy0">=</span> newNode<span class="sy0">;</span>
		LQ<span class="sy0">-&gt;</span>rear <span class="sy0">=</span> newNode<span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> deQueue<span class="br0">&#40;</span>LQueueType <span class="sy0">*</span>LQ<span class="br0">&#41;</span><span class="br0">&#123;</span>
	QNode <span class="sy0">*</span>old <span class="sy0">=</span> LQ<span class="sy0">-</span>front<span class="sy0">;</span>
	<span class="kw4">int</span> item<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span>isEmpty<span class="br0">&#40;</span>LQ<span class="br0">&#41;</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">else</span><span class="br0">&#123;</span>
		item <span class="sy0">=</span> old<span class="sy0">-&gt;</span>data<span class="sy0">;</span>
		LQ<span class="sy0">-&gt;</span>front <span class="sy0">=</span> LQ<span class="sy0">-&gt;</span>front<span class="sy0">-&gt;</span>link<span class="sy0">;</span>
		<span class="kw1">if</span><span class="br0">&#40;</span>LQ<span class="sy0">-&gt;</span>front <span class="sy0">==</span> NULL<span class="br0">&#41;</span>
			LQ<span class="sy0">-&gt;</span>rear <span class="sy0">=</span> NULL<span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">&#40;</span>old<span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span> item<span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">////// 큐 연산 &gt;&gt;</span>
&nbsp;
<span class="kw4">void</span> createGraph<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw4">int</span> v<span class="sy0">;</span>
	g<span class="sy0">-&gt;</span>n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">&#40;</span>v<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> v<span class="sy0">&lt;</span>MAX_VERTEX<span class="sy0">;</span> v<span class="sy0">++</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
		g<span class="sy0">-&gt;</span>visited<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy0">=</span> FALSE<span class="sy0">;</span>
		g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy0">=</span>NULL<span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="kw4">void</span> insertVertex<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="sy0">,</span> <span class="kw4">int</span> v<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>g<span class="sy0">-&gt;</span>n<span class="br0">&#41;</span><span class="sy0">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">&gt;</span>MAX_VERTEX<span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span> 그래프 정점의 개수를 초과하였습니다!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	g<span class="sy0">-&gt;</span>n<span class="sy0">++;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> insertEdge<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="sy0">,</span> <span class="kw4">int</span> u<span class="sy0">,</span> <span class="kw4">int</span> v<span class="br0">&#41;</span><span class="br0">&#123;</span>
	graphNode<span class="sy0">*</span> node<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">&#40;</span>u<span class="sy0">&gt;=</span>g<span class="sy0">-&gt;</span>n <span class="sy0">||</span> v<span class="sy0">&gt;=</span>g<span class="sy0">-&gt;</span>n<span class="br0">&#41;</span><span class="br0">&#123;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">&#40;</span><span class="st0">&quot;<span class="es1">\n</span> 그래프에 없는 정점입니다!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">return</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
	node <span class="sy0">=</span> <span class="br0">&#40;</span>graphNode <span class="sy0">*</span><span class="br0">&#41;</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span>graphNode<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	node<span class="sy0">-&gt;</span>vertex <span class="sy0">=</span> v<span class="sy0">;</span>
	node<span class="sy0">-&gt;</span>link <span class="sy0">=</span> g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>u<span class="br0">&#93;</span><span class="sy0">;</span>
	g<span class="sy0">-&gt;</span>adjList_H<span class="br0">&#91;</span>u<span class="br0">&#93;</span> <span class="sy0">=</span> node<span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> print_adjList<span class="br0">&#40;</span>graphType<span class="sy0">*</span> g<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
	graph
	...
<span class="br0">&#125;</span></pre>
</dd></dl>

</div>
<!-- EDIT11 SECTION "(2) 너비 우선 탐색" [10828-14118] -->
<h2 class="sectionedit12" id="신장_트리와_최소_비용_신장_트리">04 신장 트리와 최소 비용 신장 트리</h2>
<div class="level2">

</div>
<!-- EDIT12 SECTION "04 신장 트리와 최소 비용 신장 트리" [14119-14178] -->
<h3 class="sectionedit13" id="신장_트리">(1) 신장 트리</h3>
<div class="level3">

<p>
그래프의 관점에서 트리는 사이클이 없는 단순 연결 그래프다. n개의 정점으로 이루어진 무방향 그래프 G에서 n개의 모든 정점과 n-1개의 간선으로 만들어진 트리를 신장 트리(spanning tree)라고 한다. 
</p>

<p>
깊이 우선 탐색을 이용하여 생성된 신장 트리를 깊이 우선 신장 트리(depth first spanning tree)라 하고, 너비 우선 탐색을 이용하여 생성된 신장 트리를 너비 우선 신장 트리(breadth first spanning tree)라고 한다.
</p>

</div>
<!-- EDIT13 SECTION "(1) 신장 트리" [14179-14734] -->
<h3 class="sectionedit14" id="최소_비용_신장_트리">(2) 최소 비용 신장 트리</h3>
<div class="level3">

<p>
가중치 그래프에서 간선에 주어지는 가중치는 비용이나 거리, 시간을 의미하는 값이 될 수 있다. 따라서 무방향 가중치 그래프에서 신장 트리의 비용은 신장 트리를 구성하는 간선들의 가중치의 합이 되는데, 가중치의 합이 최소인 신장 트리를 최소 비용 신장 트리라고 한다.
</p>

<p>
최소 비용 신장 트리를 만드는 방법으로 Kruskal이 만든 알고리즘과 Prime이 만든 알고리즘을 주로 사용한다.
</p>

</div>

<h4 id="kruskal_알고리즘">Kruskal 알고리즘</h4>
<div class="level4">

<p>
Kruskal 알고리즘은 가중치가 높은 간선을 제거하면서 최소 비용 신장 트리를 만드는 Kruskal 알고리즘 I와 가중치가 낮은 간선을 삽입하면서 최소 비용 신장 트리를 만드는 Kruskal 알고리즘 II가 있다.
</p>

</div>

<h4 id="prime_알고리즘">Prime 알고리즘</h4>
<div class="level4">

<p>
Prime 알고리즘은 간선을 정렬하지 않고 하나의 정점에서 시작하여 트리를 확장해 나가는 방법이다.
</p>

</div>
<!-- EDIT14 SECTION "(2) 최소 비용 신장 트리" [14735-] -->