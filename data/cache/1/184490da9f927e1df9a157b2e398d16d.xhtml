
<h1 class="sectionedit1" id="chapter_04_디자인_패턴">Chapter 04 디자인 패턴</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Chapter 04 디자인 패턴" [1-41] -->
<h2 class="sectionedit2" id="디자인_패턴의_이해">4.1 디자인 패턴의 이해</h2>
<div class="level2">

<p>
디자인 패턴이란 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 수 있는 훌륭한 해결책이라고 이해하면 된다. 
</p>

<p>
디자인 패턴의 구조는 3개의 필수적인 요소로 구성된다
</p>

<p>
<strong>콘텍스트</strong> : 문제가 발생하는 여러 상황을 기술한다. 즉 패턴이 적용될 수 있는 상황을 나타낸다. 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.<br/>

<strong>문제</strong> : 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다. 이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.<br/>

<strong>해결</strong> : 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다. 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 잇는 일종의 템플릿이다.<br/>

</p>

<p>
<strong>Key point</strong> 아키텍처 패턴, 디자인 패턴, 관용구는 다음과 같이 구분한다.
</p>

<p>
<strong>아키텍처 패턴</strong> : 시스템을 구성하는 컴포넌트의 구성과 컴포넌트 사이의 협조 방법을 패턴화한 것이다.
<strong>디자인 패턴</strong> : 아키텍처 패턴에서 컴포넌트의 내부 구조를 대상으로 한 클래스/객체의 구조와 협업 방법을 패턴화한 것이다.
<strong>관용구</strong> : 각각의 프로그램 언어 특유의 패턴, 프로그래밍에서 자주 사용하는 기술 방법(코딩 방법)을 패턴화한 것이다.
</p>

</div>
<!-- EDIT2 SECTION "4.1 디자인 패턴의 이해" [42-1674] -->
<h2 class="sectionedit3" id="gof_디자인_패턴">4.2 GoF 디자인 패턴</h2>
<div class="level2">

<p>
에리히 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스는 소프트웨어 개발 영역에서 디자인 패턴을 구조화하고 체계화한 GOF라  불리는 사람들의 이름이다. 이들은 디자인 패턴을 23가지로 정리하고, 생성, 구조, 행위의 3가지로 분류했다.
</p>

<p>
GoF 디자인 패턴의 분류
</p>
<div class="table sectionedit4"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0"> </th><th class="col1"> 생성 패턴 </th><th class="col2"> 구조 패턴 </th><th class="col3"> 행위 패턴 </th>
	</tr>
	</thead>
	<tr class="row1">
		<td class="col0" rowspan="11"> 패턴 이름 </td><td class="col1"> 추상 팩토리(Abstract Factory) </td><td class="col2"> 어댑터(Adapter) </td><td class="col3"> 책임 연쇄(Chain of Responsibility) </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 빌더 (Builder) </td><td class="col1"> 컴퍼지트(Composite) </td><td class="col2"> 커맨드 (Command) </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 팩토리 메서드 (Factory Method) </td><td class="col1"> 데코레이터(Decorator) </td><td class="col2"> 인터프리터(Interpreter) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 프로토타입(Prototype) </td><td class="col1"> 퍼사드(facade) </td><td class="col2"> 이터레이터(Iterator) </td>
	</tr>
	<tr class="row5">
		<td class="col0" rowspan="7"> 싱글턴(Singleton) </td><td class="col1"> 플라이웨이트(Flyweight) </td><td class="col2"> 미디에이터(Mediator) </td>
	</tr>
	<tr class="row6">
		<td class="col0" rowspan="6"> 프록시(Proxy) </td><td class="col1"> 메멘토(Memento) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 옵저버(Observer) </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 스테이트(State) </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 스트래티지(Strategy) </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 템플릿 메서드(Template Method) </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 비지터(Visitor) </td>
	</tr>
</table></div>
<!-- EDIT4 TABLE [2054-2867] -->
<p>
생성 패턴은 객체 생성에 관련된 패턴으로, 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다. 대표적인 생성 패턴으로는 팩토리 메서드, 추상 팩토리, 빌더, 프로토타입, 싱글턴 패턴이 있다.
</p>

<p>
구조 패턴은 클래스나 객체를 조합해 더 큰 구조를 만든는 패턴이다. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다. 대표적인 구조 패턴으로는 어댑터, 퍼사드, 브리지, 컴퍼지트, 플라이웨이트 패턴 등이 있다.
</p>

<p>
행위 패턴은 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이다. 가령 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다. 대표적인 행위 패턴으로는 커맨드, 인터프리터, 이터레이터, 미디에이터, 메멘토, 옵저버, 스테이트, 스트래티지, 비지터 등이 있다.
</p>

</div>
<!-- EDIT3 SECTION "4.2 GoF 디자인 패턴" [1675-4135] -->
<h2 class="sectionedit5" id="uml과_디자인_패턴">4.3 UML과 디자인 패턴</h2>
<div class="level2">

<p>
UML 2.0에서 디자인 패턴을 표현하는 도구로 콜라보레이션(Collaboration)이 있다. 콜라보레이션을 통해 디자인 패턴을 정확하게 표현하려면 구조적인 면과 행위적인 면을 모두 표현할 필요가 있다. 구조적인 면에서는 어떤 요소들이 주어진 목적을 달성하기 위해 협력하는지를 나타내고 행위적인 면에서는 협력을 위한 요소들의 상호작용을 나타낸다. 
</p>

</div>
<!-- EDIT5 SECTION "4.3 UML과 디자인 패턴" [4136-4635] -->
<h3 class="sectionedit6" id="콜라보레이션">4.3.1 콜라보레이션</h3>
<div class="level3">

<p>
어떤 주어진 목적을 달성하고자 할 때 여러 객체가 각자 자신이 맡은 역할에 따라 일을 수행하며 서로 협럭한다.
</p>

<p>
여기에서 주목할 점은 객체와 역할 사이의 관계다. 객체는 역할이 아니므로 한 객체가 여러 역할을 수행할 수 있다. 디자인 패턴 역시 목적을 달성하기 위한 역할들의 상호 협동 작업으로 간주할 수 있다. 그리고 UML에서는 객체들이 특정 상황에서 수행하는 역할의 상호작용을 콜라보레이션이라는 요소로 작성한다.
</p>

<p>
UNL에서 콜라보레이션은 점선으로 된 타원 기호를 사용하며 타원 내부에 협력을 필요로 하는 역할들과 그들 사이의 연결 관계를 표현한다.
</p>
<pre class="code">콜라보레이션은 객체가 수행하는 역할들의 협력을 표현해준다.</pre>

<p>
콜라보레이션은 역할들의 상호작용을 추상화한 것으로, 특별한 상황에 적용하면 많은 시스템 개발에 재사용할 수 있다. 콜라보레이션 어커런스는 더 구체적인 상황에서의 콜라보레이션 적용을 표현해준다. 
</p>

</div>
<!-- EDIT6 SECTION "4.3.1 콜라보레이션" [4636-5790] -->
<h3 class="sectionedit7" id="순차_다이어그램">4.3.2 순차 다이어그램</h3>
<div class="level3">

<p>
순차 다이어그램은 UML 2.0에서 객체들의 상호작용을 나타내는 다이어그램 중 하나다. 순차 다이어그램은 객체들 사이의 메시지 송신과 그들의 순서를 나타낸다. 객체는 가장 윗부분에 표현되고, 왼쪽에서 오른쪽으로 객체들을 나열한다. 객체 다이어그램에서 객체를 표현하는 표기와 동일하게 &#039;객체 이름 : 클래스 이름&#039; 형식을 이용해 표기하며 이 중 어느 한쪽을 생략해 표기할 수 있다.
</p>

<p>
객체 아래에는 점선이 뻗어 가는데, 이것은 생명선(lifeline)이라 하고 해당 객체가 존재함을 보여준다. 생명선을 따라서 좁고 긴 사각형이 나올 수 있다. 이 상자를 &#039;활성 구간(activation)&#039;이라 한다. 이는 실제로 객체가 연산을 실행하는 상태임을 보여준다. 활성 구간의 크기는 실행 시간을 고려해서 적당히 설정한다.
</p>

<p>
객체 사이의 메시지는 화살표로 표시한다. 물론 화살표의 시작 부분은 메시지를 송신하는 객체를 나타내고 화살표의 끝 부분은 메시지의 수신 객체를 나타낸다. 순차 다이어그램에서 종종 머리 부분이 채워지지 않고 열려 있는 화살표를 볼 수 있는데, 이를 비동기(asynchronous)메시지를 나타낸다. 비동기 메시지는 메시지를 송신한 후 메시지 실행이 끝나기를 기다리지 않고 다음 작업을 바로 수행할 수 있다. 이에 반해 머리 부분이 채워진 메시지는 동기 메시지라 하며 메시지의 실행을 요청하는 객체가 메시지의 실행이 종료될 때까지 다음 작업을 수행할 수 없다.
</p>

<p>
메시지를 표현할 때는 보통 다음과 같은 형식을 따른다.
</p>
<pre class="code">[시퀀스 번호][가드]:반환 값:=메시지 이름([인자 리스트])</pre>

<p>
메시지 이름을 제외하고는 모두 생략할 수 있다. 시퀀스 번호는 순차 다이어그램에서 굳이 기술할 필요가 없다. 생명선에 따라 시간이 위에서 아래로 지나가기 때문이다. 가드(guard)는 메시지가 송신되는 데 만족해야 하는 조건이다. 또한 점선 화살표는 응답(reply) 메시지를 표현한다. 응답 메시지는 메시지가 종료되었음을 표현하며 반드시 표기해야 하는 것은 아니다.
</p>

</div>
<!-- EDIT7 SECTION "4.3.2 순차 다이어그램" [5791-8151] -->
<h3 class="sectionedit8" id="순차_다이어그램과_클래스_다이어그램의_관계">4.3.3 순차 다이어그램과 클래스 다이어그램의 관계</h3>
<div class="level3">

<p>
순차 다이어그램은 객체 사이의 메시지 흐름과 순서를 알려주는 행위 측면에 중점을 두는 모델이고, 클래스 다이어그램은 시스템의 구조적인 측면에 중점을 두는 모델이다. 
</p>

</div>
<!-- EDIT8 SECTION "4.3.3 순차 다이어그램과 클래스 다이어그램의 관계" [8152-] -->