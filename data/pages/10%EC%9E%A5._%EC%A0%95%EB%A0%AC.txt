====== 10장. 정렬 ======
===== 01 정렬 =====
==== (1) 정렬의 개념 ====
정렬이란 순서 없이 배열되어있는 자료들을 작은 것부터 큰 것 순서의 오름차순이나 큰 것부터 작은 것 순서의 내림차순으로 재배열하는 것이다.

==== (2) 정렬 방법의 분류 ====
정렬 방법은 실행하는 방법과 정렬이 수행되는 장소에 따라서 분류할 수 있다.
=== 실행 방법에 따른 분류 ===
정렬은 실행하는 방법에 따라 비교식 정렬(comparative sort)과 분산식 정렬(distribute sort)로 구분할 수가 있다. 비교식 정렬은 비교하고자 하는 각 키값들을 한번에 두 개씩 비교하여 교환함으로써 정렬을 실행하는 방식이다. 그리고 분산식 정렬은 키값을 기준으로 하여 자료를 여러 개의 부분집합으로 분해하고, 각 부분집합을 정렬함으로써 전체를 정렬하는 방식이다.
=== 정렬 장소에 따른 분류 ===
== 내부 정렬 ==
내부 정렬은 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식으로, 정렬 속도는 빠르지만 정렬할 수 있는 자료의 양이 메인 메모리의 용량에 따라 제한된다.
  * 교환 방식 : 키를 비교하고 교환하여 정렬하는 방식(선택 정렬, 버블 정렬, 퀵 정렬)
  * 삽입 방식 : 키를 비교하고 삽입하여 정렬하는 방식(삽입 정렬, 셀 정렬)
  * 병합 방식 : 키를 비교하고 병합하여 정렬하는 방식(2-way 병합, n-way 병합)
  * 분배 방식 : 키를 구성하는 값을 여러 개의 부분집합에 분배하여 정렬하는 방식(기수 정렬)
  * 선택 방식 : 이진 트리를 사용하여 정렬하는 방식(히프 정렬, 트리 정렬)
== 외부 정렬 ==
외부 정렬은 대용량의 보조 기억 장치를 사용하기 때문에 내부 정렬보다 속도는 떨어지지만, 내부 정렬로 처리할 수 없는 대용량의 자료를 정렬할 수 있다.
  * 병합 방식 : 파일로 부분 파일을 분리하여 각가을 내부 정렬 방법으로 정렬하여 병합하는 정렬 방식

===== 02 선택 정렬 =====
==== (1) 선택 정렬의 이해 ====
선택 정렬은 전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬한다. 전체 원소 중에서 가장 작은 원소를 찾아서 선택하고 첫 번째 원소와 자리를 교환한다. 다음은 두 번째로 작은 원소를 찾아 선택하여 두 번째 원소와 자리를 교환하고, 그 다음에는 세 번재로 작은 우너소를 찾아서 세 번째 원소와 자리를 교환한다.
==== (2) 선택 정렬 알고리즘 ====
다음은 크기가 n인 배열 a[]의 원소들을 선택 정렬하는 알고리즘이다.

	selectionSort(a[], n)
		for(i<-1; i<n; i<-i+1){
			a[i], ..., a[n-1] 중에서 가장 작은 원소 a[k]를 선택하여,
			a[i]와 교환한다.
		}
	end selectionSort()

	void selectionSort(int a[], int n){
		int i,j,min,temp;
		for(i=0; i<n-1; i++){
			min = i;
			for(j=j+1; j<n;j++){
				if(a[j]<a[min])
					min = j;
			}
			temp = a[i];
			a[i] = a[min];
			a[min] = temp;
		}
	}

===== 03 버블 정렬 =====
==== (1) 버블 정렬의 이해 ====
버블 정렬은 인접한 두개의 원소를 비교하여 자리를 교환하는 방식으로, 첫 번째 원소부터 마지막 원소까지 반복하면 가장 큰 원소가 마지막 자리에 온다. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리로 이동한다.
==== (2) 버블 정렬 알고리즘 ====
다음은 크기가 n인 배열 a[]의 원소들을 버블 정렬하는 알고리즘이다.

	void bubbleSort(int a[], int n){
		int i, j, temp;
		for(i=n-1;i>=0;i--){
			for(j=0; j<=i; j++){
				if(a[j-1]>a[j]){
					temp = a[j-1]l;
					a[j-1] = a[j];
					a[j] = temp;
				}
			}
		}
	}

==== (3) 버블 정렬 프로그램 ====

===== 04 퀵정렬 =====
==== (1) 퀵 정렬의 이해 ====
퀵 정렬은 정렬할 전체 원소에 대해서 정렬을 수행하지 않고 기준값을 중심으로 왼쪽 부분집합과 오른쪽 부분집합으로 분할(divide)한다. 왼쪽 부분에는 기준값보다 작은 원소들을 이동시키고 오른쪽 부분집합에는 기준값보다 큰 원소들을 이동시킨다. 이때 사용하는 기준값을 피봇(pivot)이라 하는데, 일반적으로 전체 원소 중에서 가운데에 위치한 원소를 피봇으로 선택한다.

퀵 정렬은 다음의 2가지 기본 작업을 반복 수행하여 완성한다.

  * (1) 분할(divide) : 정렬할 자료들을 기준값을 중심으로 2개의 부분집합으로 분할한다.
  * (2) 정복(conquer) : 부분집합의 원소들 중에서 기준값보다 작은 원소들은 왼쪽 부분집합으로, 기준값보다 큰 원소들은 오른쪽 부분집합으로 정렬한다. 부분집합의 크기가 1이하로 충분히 작지 않으면 순환 호출을 이용하여 다시 분할한다.

==== (2) 퀵 정렬 알고리즘 ====
	quickSort(a[], begin, end)
		if(m<n) then{
			p <- partition(a, begin, end);
			quickSort(a[], begin, p-1);
			quickSort(a[], p+1, end);
		}
	end quickSort()

	partition(a[], begin, end)
		pivot <- (begin + end)/2;
		L <- begin;
		R <- end;
		while(L<R) do{
			while(a[L] < a[pivot] and L<R)
				do L++;
			while(a[R] < a[pivot] and L<R)
				do R--;
			if(L<R)
				then{
					temp <- a[L];
					a[L] <- a[R];
					a[R] <- temp;
				}
		}
		temp <- a[pivot];
		a[pivot] <- a[L];
		a[L] <- temp;
		return L;
	end partition()

<file c QuickSort.c>
# include <stdio.h>

int size, i=0;

int partition(int a[], int begin, int end){
	int pivot, temp, L, R, t;
	L = begin;
	R = end;
	pivot = (begin+end)/2;
	printf("\n [ %d단계 : pivot=%d ] \n", ++i, a[pivot]);
	while(L<R){
		while((a[L]<a[pivot]) && (L<R)) L++;
		while((a[R]>=a[pivot])&&(L<r)) r--;
		if(L<R){
			temp = a[L];
			a[L] = a[R];
			a[R] = temp;
		}
	}
	
	temp = a[pivot];
	a[pivot] = a[R];
	a[R] = temp;
	for(t=0; t<size; t++)
		printf("	%d", a[t]);
	printf("\n");
	return L;
}

void quickSort(int a[], int begin, int end){
	if(begin<end){
		int p;
		p = partition(a, begin, end);
		quickSort(a, begin, p-1);
		quickSort(a, p+1, end);
	}
}

void main(){
	int list[8] = {69, 10, 30, //);
	size = 8;
	quickSort(list, 0, size-1);
	getchar();
}
</file>

===== 05 삽입 정렬 =====
==== (1) 삽입 정렬의 이해====
삽입 정렬은 정렬되어 있는 부분집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법이다. 삽입 정렬에서는 정렬할 자료가 두 개의 부분집합 S와 U로 나뉘어 있다고 생각한다. 앞부분 원소부터 정렬을 수행하는데, 정렬된 앞부분의 원소들은 부분집합 S가 되고 아직 정렬되지 않은 나머지 원소들은 부분집합 U가 된다. 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내어 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입하여 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 줄인다. U의 원소를 모두 삽입하여 공집합이 되면 삽입 정렬이 완성된다.

==== (2) 삽입 정렬 알고리즘 ====
	void insertionSort(int a[], int n){
		int i, j, temp;
		for(i=1; i<n; i+){
			temp = a[i];
			j = i;
			while((j>0) && (a[j-1]>temp){
				a[j] = a[j-1];
				j = j-1;
			}
			a[j] = temp;
		}
	}


===== 05 셸 정렬 =====
==== (1) 셸 정렬의 이해 ====
셸 정렬은 일정한 간격(interval)으로 떨어져 있는 자료들끼리 부분집합을 구성하고 각 부분집합에 있는 원소들에 대해서 삽입 정렬을 수행하는 작업을 반복하면서 전체 원소들을 정렬하는 방법이다. 전체 원소에 대해서 삽입 정렬을 수행하는 것보다 부분집합으로 나누어 정렬하게 되면 비교 연산과 교환 연산의 횟수를 줄일 수 있다.

셸 정렬에서 부분집합을 만드는 기준이 되는 간격을 매개변수 h에 저장하고 한 단계가 수행될 때마다 h의 값을 감소시키고 셸 정렬을 순환 호출하는데, 결국 h가 1이 될 때까지 반복한다. 셸 정렬의 성능은 매개변수 h의 값에 따라 달라진다. 일반적으로 사용하는 h의 값은 원소 개수의 1/2을 사용하고 한 단계 수행될 때마다 h의 값을 반으로 감소시키면서 반복 수행한다. 
==== (3) 셸 정렬 프로그램 ====
