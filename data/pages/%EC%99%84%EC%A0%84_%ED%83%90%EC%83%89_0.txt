====== 완전 탐색 0 ======
===== 비트마스크 =====
  * 비트마스크
    * 비트(bit) 연산을 사용해서 부분 집합을 표현할 수 있다.
  * 비트 연산
    * &(and), |(or), ~(not), ^(xor)
    * xor 연산은 두 값의 각 자릿수를 비교해, 값이 0으로 같거나 1로 같으면 0, 다르면 1을 계산한다.
    * 두 수 A와 B를 비트 연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 된다.
    * not 연산의 경우에는 자료형에 따라 결과가 달라진다. 
    * shift left(<<), shift right(>>)
      * A << B (A를 왼쪽으로 B비트만큼 민다.)
      * 1 << 0 = 1
      * 1 << 1 = 2
      * 1 << 2 = 4
      * 1 << 3 = 8
      * 1 << 4 = 16
      * 3 << 3 = 24 
      * 5 << 10 = 5120
    * A << B : A x 2^B와 같다.
    * A >> B는 A/2^B와 같다.
    * (A + B) / 2는 (A + B) >> 1로 쓸 수 있다.
    * 어떤 수가 홀수 인지 판별하는 if(N % 2 == 1)은 if(N & 1)로 줄여 쓸 수 있다.
    * {1, 3, 4, 5, 9} = 570
      * 1 추가하기 570 
    * 현재 집합이 S 일때
      * i를 추가
        * S | (1 << i)
      * i를 검사
        * S & (1 << i)
      * i를 제거
        * S & ~(1 << i)
      * i를 토글
        * S ^ (1 << i)
    * 집합 11723
      * 완료
  * 배열이 더 편리하지만 비트마스크를 사용하는 이유
    * 집합을 배열의 인덱스로 표현할 수 있기 때문이다.
    * 상태 다이나믹을 할 때 자주 사용하게 된다.
  * bitset
      * 비트마스크는 STL의 bitset을 이용해서 더 쉽게 나타낼 수 있다.

====== 순열 ======
  * 순열
    * 1 ~ N 까지로 이루어진 순열
    * 크기가 N인 순열은 총 N! 개가 존재한다
  * 다음 순열
    * 1) A[i-1] < A[i]를 만족하는 가장 큰 i를 찾는다.
    * 2) j >= i 이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾는다.
    * 3) A[i-1]과 A[j]를 swap 한다.
    * 4) A[i]부터 순열을 뒤집는다.
  * 순열의 순서
    * 1부터 N까지의 수를 임의로 배열한 순열은 총 N! 가지가 있다.
    * 어떤 순열이 몇번째 순열인지 구하는 방법
    * N = 7
      * 1,?,?,... : 6!개
      * 2,?,?,... : 6!개
      * 5,1,?,... : 5!개
      * 5,2,1,?,.. : 4!개
    * 문제 1722 