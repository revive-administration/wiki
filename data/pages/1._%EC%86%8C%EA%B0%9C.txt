====== 1. 소개 ======
루비는 복잡하지만, 표현이 다양한 동적(dynamic) 프로그래밍 언어로서 풍부하고 강력한 API로 구성된 코어 클래스 라이브러리를 제공합니다. 루비는 LISP, Smalltalk, Perl 언어의 영향을 받았지만 C와 Java 프로그래머도 배우기 쉬운 문법으로 되어 있습니다. 루비는 순수한 객체지향 언어이긴 하지만, 절차적 혹은 함수형 프로그래밍에도 잘 어울립니다. 강력한 메타프로그래밍 기능이 있어서 도메인 특정 언어(domain-specific languages)로 쓸 수도 있습니다.

====1.1 루비와 떠나는 여행====
===1.1.1 루비는 객체지향===
루비는 완전한 객체지향 언어입니다. 숫자나 true, false, nil(루비에서 null을 의미하는 값) 같은 값도 모두 객체입니다. 루비는 객체의 캡슐화를 엄격하게 지키므로 객체 외부에서 객체 내부 상태를 볼 수 없습니다. 따라서 모든 접근은 class 메서드처럼 접근 메서드를 사용해야 합니다.
===1.1.2 블록과 반복자 ===
상수도 메서드를 부를 수 있다는 건 루비의 난해한 면만은 아닙니다. 반복문을 작성할 때 루비 프로그래머의 무기가 됩니다.
===1.1.3 식과 연산자 ===
루비의 구문은 식(expression)을 기반으로 합니다. if 같은 제어 구조는 다른 언어에서 문(statement)이라고 하지만 루비에서는 식입니다. 다른 식에서 제어 구조도 값을 가지고 있어서 이런 코드를 작성할 수 있습니다.

<file ruby 1.1.3.rb>
minimum = if x<y then x else y end
</file>

비록 루비에서 모든 문이 식이기는 하지만, 의미 있는 반환값만 있는 건 아닙니다. 예를 들어 while 루프와 메서드 정의는 보통 nil을 반환하는 식입니다. \\ 대다수 언어처럼 루비의 식은 값과 연산자로 구성됩니다. C, 자바, 자바스크립트 같은 언어를 아는 사람이라면 루비 연산자를 봤을 때 친숙한 느낌이 들 겁니다. 


===1.1.4 메서드===

def 키워드로 정의하면 메서드가 됩니다. 본문에서 실행한 마지막 값이 메서드 반환값이 됩니다.

<file ruby 1.1.4-1.rb>
def square(x)   # x라는 인수를 가진 square 메서드를 정의
  x*x           # x 제곱값 반환
end             # 메서드 끝
</file>

이와 같은 메서드가 모듈이나 클래스 바깥에서 정의되면 전역 함수와 비슷해집니다(엄밀하게 말하면 이런 메서드는 Object 클래스의 private 메서드가 됩니다). 메서드 이름 앞에 접두어로 클래스 이름을 붙이면 각각의 객체에 메서드를 정의하는 것과 같아집니다. 이런 메서드를 싱글톤 메서드(singleton methods)라 하며 다음과 같이 정의합니다.

<file ruby 1.1.4-2.rb>
def Math.square(x)
  x*x
end
</file>

중요 루비 라이브러리인 Math 모듈에 새로운 메서드를 추가했습니다. 이렇듯 루비 클래스와 모듈은 '열려' 있으므로 실행할 때 수정하거나 확장할 수 있습니다. 중요한 특징이지요. 메서드 인수로 특정한 기본값을 지정할 수 있고 메서드를 이루는 구문의 개수는 얼마든지 가능합니다.

===1.1.5 대입===
= 연산자(재정의할 수 없음)로 변수에 값을 대입합니다.

<file ruby 1.1.5-1.rb>
  x=1
</file>

<file ruby 1.1.5-2.rb>
# 데카르트(직교) 좌표(x,y)를 극좌표(Polar)로 변환하는 메서드를 정의
def polar(x,y)
  theta = Math.atan2(y,x)
  r = Math.hypot(x,y)
  [r, theta]
end

# 다중 대입으로 메서드를 사용
distance, angle = polar(2,2)
</file>

===1.1.8 클래스와 모듈 ===
클래스는 객체 상태로 동작하는 연관 메서드의 집합입니다. 객체 상태는 인스턴스 변수로 유지합니다. 인스턴스 변수의 이름은 @로 시작하며 인스턴스의 값은 인스턴스 객체에 있습니다. 다음 코드는 Sequence 클래스를 정의하고, 반복자 메서드와 연산자를 작성하는 예제입니다.

<file ruby 1.1.8-1.rb>

# 이 클래스는 from, to, by라는 세 가지 인수를 받는다. 숫자 x는 다음과 같은 조건이 있다.
#
# from <= x <= to
# x = from + n*by, n은 정수
#
#
class Sequence
  # enumerable 클래스로 each 반복자를 정의
  include Enumerable                  # 모듈의 메서드를 클래스의 포함
  
  # initialize 메서드는 클래스의 인스턴스가 새롭게 생성될 때 자동으로 실행됨
  def initialize(from, to, by)
  
    # 인스턴스 변수에 인수를 보관
    @from, @to, @by = from, to, by      # @ 전치구와 다중 대입에 주의
  end

  # Enumerable 모듈에서 필요한 반복자
  def each
    x = @from
    while x <= @to
      yield x
      x += @by
    end
  end
  
  # sequence 안에 든 값의 수를 반환하는 length 메서드 정의
  def length
    return 0 if @from > @to              # if가 구문 수식자로 쓰임
    Integer((@to-@from)/@by)+1           # 수열 길이를 계산해서 반환
  end
  
  # 같은 메서드에 또다른 이름을 정의하는 것은 루비에서는 흔하다.
  alias size length                      # size는 length와 동의어
  
  # 수열에 임의로 접근하는 배열 접근 연산자를 재정의
  def[](index)
    return nil if index < 0              # 음수의 인덱스는 nil을 반환
    v = @from + index*@by                # 값을 계산
    if v <= @to                          # 배열의 일부라면
      v                                  # 그 값을 반환
    else                                 # 아니라면
      nil                                # nil을 반환
    end
  end
  
  # 새로운 Sequence 객체를 반환하는 사칙연산자로 재정의
  def *(factor)
    Sequence.new(@from*factor, @to*factor, @by*factor)
  end
  
  def +(offset)
    Sequence.new(@from+offset, @to+offset, @by)
  end
end

</file>

Sequence 클래스를 사용해 봅시다.

<file ruby 1.1.8-2.rb>
s = Sequence.new(1, 10, 2)     # 1에서 10까지 2식 증가
s.each {|x| print x}           # 출력값 "13579"
print s[s.sze-1]               # 출력값 9
t = (s+1)*2                    # 4에서 22까지 4씩 증가
</file>

===1.1.9 루비의 깜짝 기능===
루비의 문자열은 변경하기 쉬워서 때때로 자바 프로그래머를 곤혹에 빠트립니다. []= 연산자는 문자열의 글자를 바꾸거나 문자열 일부분을 삽입, 삭제, 치환하는 데 쓸 수 있습니다. << 연산자는 문자열을 추가하는 데 쓸 수 있고 String 클래스에는 수많은 메서드가 정의되어 있습니다. 문자열이 변하기 쉬워서 프로그램 속에서 문자 상수는 유일한 객체가 아닙니다. 문자 상수를 루프 안에 포함시킨다면 루프마다 새로운 객체가 생성됩니다. freeze 메서드를 문자열(또는 다른 모든 객체)에서 호출 하면 객체의 변경을 방지합니다. \\
루비의 조건문이나 반복문(if나 while같은)은 어떤 분기나 반복을 할지 판단하는 조건식을 실행합니다. 조건식은 보통 true나 false로 실행되지만 다른 값도 받습니다. nil 값은 false와 동일하게 취급되고 그 외의 값은 true와 같이 취급합니다. 이런 특성은 0이 false로 동작하기를 기대하는 C 프로그래머와 "" 문자가 false로 동작할거라고 믿는 자바스크립트 프로그래머를 충격에 빠트립니다.