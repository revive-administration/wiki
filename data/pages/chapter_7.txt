====== Chapter 7 ======
=====7-2 메모리 분할 =====
==== 고정 분할 ====
비균등 분할 방법의 단점
  * 시스템 생성시간에 미리 정해진 파티션의 수에 의해 시스템 내에서 활성화된 프로세스들의 개수가 제한을 받는다.
  * 시스템 생성 시간에 파티션 사이즈가 미리 정해지기 때문에 크기가 작은 작업들의 경우 파티션 공간을 효율적으로 활용할 수 없다.
==== 동적 분할 ====
동적 분할에서 파티션의 크기와 개수는 가변적이다. 한 프로세스가 주기억장치로 적재도리 때 정확히 요구된 크기만큼의 메모리만 할당받는다. 이러한 방법은 처음에는 잘 동작하지만 결국은 주기억장치에 작은 구멍들이 다수 만들어지는 상황이 된다. 이와 같이 모든 파티션 영역 이외의 메모리가 점차 사용할 수 없는 조각으로 변하는 현상을 외부 단편화(externel fragmentation)라고 부른다.

외부 단편화를 극복하는 방법으로 메모리 집약(compaction) 때때로 운영체제는 프로세스가 사용하는 파티션을 이동시켜 각 파티션이 연속적이 되도록 인접하게 만들고 메모리의 모든 빈 공간이 하나의 블록이 되도록 한다. 메모리 집약은 시간이 많이 걸리며 처리기 시간을 낭비하는 단점이 있다. 메모리 집약을 하기 위해서는 동적 재배치 기능이 필요하다는 점에 주목해하기 바란다. 즉 프로그램의 메모리 참조가 아무런 영향을 받지 않고 프로그램을 주기억장치 내에서 이동시킬 수 있어야 한다는 것을 의미한다

=== 배치 알고리즘 ===
프로세스를 주기억장치로 적재하거나 스왑인 하려고 할 대 충분한 크기의 사용 가능한 메모리 블로깅 두 개 이상 있다면 운영체제는 어떤 블록에 할당 할 것인지를 결정해야만 한다.

고려 가능한 배치 알고리즘에는 최적적합(best-fit), 최초적합(first-fit), 순환적합(next-fit)이 있다. 최초적합이 대체로 제일 낫다.

=== 교체 알고리즘 ===
가상메모리 기법 측면에서 다루도록 한다

==== 버디 시스템 ====
고정 분할과 동적 분할의 절충안, 버디 시스템에서는 메모리 블록이 2^K, L << K << U의 크기를 가진다. 이 때 L과 U는 다음을 만족한다.

  * 2^L = 할당된 가장 작은 크기의 블록
  * 2^U = 할당된 가장 큰 크기의 블록, 보통 할당 가능한 전체 메모리의 크기와 같다.

===재배치 ===
프로세스에 의해 참조된 위치는 고정되지 않으므로 명령어와 데이터의 위치는 스왑인되거나 이동될 때마다 변경된다. 이러한 문제를 해결하기 위해 프로세스 생성이나 실행에 사용되는 주소를 몇 가지 유형으로 구분한다. 논리주소란 현재 데이터가 적재된 메모리와는 독립적인 메모리 위치에 대한 참조이다. 이 주소는 실제 메모리 접근을 위해서 반드시 그전에 물리주소로 변환되어야 한다. 상대주소란 논리주소의 특별한 예인데, 어떤 알려진 지점, 주로 처리기의 한 레지스터의 값으로부터 상대적인 위치를 의미하는 주소이다. 물리주소 또는 절대주소란 주기억장치 안에서의 실제 위치를 말한다.

=====7.3 페이징 ======
주기억 장치를 비교적 작은 고정 사이즈 파티션으로 나루고 각 프로세스 또한 같은 크기의 고정 조각으로 나눈다고 가정해보자. 페이지라고 불리는 이 프로세스 조각은 프레임 또는 페이지 프레임이라고 알려진 빈 메모리의 조각에 저장될 수 있다. 이 기법에서는 외부단편화로 인한 메모리 낭비는 없고 내부단편화로 인한 낭비만이 존재하는데 그것도 각 프로세스의 마지막 페이지에서만 발생한다. 운영체제는 각 프로세스마다 하나의 페이지 테이블을 유지한다. 페이지 테이블은 프로세스의 각 페에지들에 해당하는 프레임의 위치를 관리한다. 프로그램 안에서 각 논리주소는 페이지 번호와 페이지 내의 오프셋으로 구성된다. 단순 분할의 경우, 논리주소는 프로그램의 시작 위치로부터 상대적인 값으로, 처리기는 그 논리주소를 물리주소로 변환시킨다. 페이징에서노 논리-물리주소 변환은 처리기에 의해서 하드웨어적으로 행하여 진다. 그러면 처리기는 수행 중인 프로세스의 페이지 테이블에 어떻게 접근할 것인지에 대해 알아야만 한다. 논리주소(페이지 번호, 오프셋)가 주어지면 처리기는 페이지 테이블을 이용하여 물리주소(프레임 숫자, 오프셋)를 생성한다. 

===== 7.4 세그먼테이션 =====
사용자 프로그램은 세그먼테이션 기법을 이용하여 나누어질 수 있는 데 프로그램과 그와 관련된 데이터들이 여러 세그먼트로 나누어진다. 세그먼트의 최대 길이에는 제한이 있더라도 프로그램의 모든 세그먼트가 같은 크기일 필요는 없다. 페이징 기법에서와 같이, 세그먼테이션을 사용할 때의 논리 주소도 세그먼테이션 번호와 오프셋 두 개의 영역으로 구성된다. 

비균등 크기의 세그먼트롤 사용하기 때문에 세그먼테이션은 동적 분할과 유사하다. 가상 메모리나 오버레이 같은 방법을 같이 사용하지 않는다면 모든 프로그램의 세그먼트들을 실행을 위해 전부 메모리로 적재되어야 한다. 동적 할당과의 차이점은 세그먼테이션의 경우 프로그램이 하나 이상의 파티션을 차지할 수 있고, 이 파티션들이 연속적일 필요는 없다는 것이다. 세그먼테이션은 내부단편화는 발생시키지 않지만, 동적 할당 기법과 마찬가지로 외부 단편화를 초래한다. 그러나 프로세스가 보다 작은 크기의 여러 조각으로 나누어지기 때문에 외부 단편화는 상대적으로 적은 편이다.

페이징이 프로그래머에게 투명한 것에 비하여 세그먼테이션은 보통 프로그래머가 각 세그먼트를 지정할 수 있으며 프로그램과 데이터를 편의대로 나누기 위한 수단으로 제공된다. 일반적으로 프로그래머나 컴파일러는 프로그램과 데이터를 다른 세그먼트들로 할당한다. 구조적 프로그래밍을 위하여 프로그램 또는 데이터는 더 세분화된 여러 세그먼트로 나뉠 수 있다. 이런 세그먼트 기법을 사용하는 데 있어 가장 불편한 점은 프로그래머가 세그먼트의 최대 크기를 알고 있어야 한다는 점이다.

비균등 세그먼트를 사용할 때 또 하나의 단점은 논리주소와 물리주소 간에 간단한 관계가 없다는 것이다. 페이징과 유사하게 단순 세그먼테이션 기법은 각 프로세스마다 세그먼트 테이블을 이용하고 주기억장치의 사용 가능한 블록들의 리스트를 유지한다. 세그먼트 테이블의 각 항목은 대응되는 세그먼트의 주기억장치 내에 세그먼트의 길이를 제공해야 한다. 하나의 프로세스가 실행 상태가 될 때 그 프로세스가 사용하는 세그먼트 테이블 주소가 메모리-관리 하드웨어가 사용하는 지정된 레지스터로 적재된다. 단순 세그먼테이션에서 프로세스는 다수의 균등하지 않은 크기의 세그먼트로 나누어진다. 프로세스가 메모리로 적재될 경우 프로세스가 모든 세그먼트가 사용가능한 메모리 영역에 할당되어지고 그에 따라 세그먼트 테이블의 값이 설정된다.